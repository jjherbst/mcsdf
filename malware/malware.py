"""
Educational Malware Sample Generator - Creates a controlled executable that 
contains embedded malicious indicators without actually performing harmful 
actions, specifically designed for testing static analysis tools and malware 
detection systems.
"""
import subprocess
import os
import base64
import sys
from pathlib import Path
import winreg

def embed_suspicious_network_markers():
    """
    description: Embeds malicious network indicators including C2 domains and attack IPs for static analysis detection
    parameters: None
    returns: dict containing domains list and ips list with embedded network indicators
    """
    attack_ip_addr = ["185.100.87.84", "192.168.1.1", "10.0.0.1", "172.16.0.1"]

    hacker_domain = [
        "https://www.fake.hacker.com",
        "https://www.evil.malicious.com", 
        "https://www.malicious.anonymous.com"
    ]
    
    hacker_domain_commands = [
        "Connect to 185.100.87.84 on port 8080",
        "Backup server: 192.168.1.1",
        "C2 server IP: 10.0.0.1",
        "Attack target: 172.16.0.1",
        "Visit https://www.fake.hacker.com for more information",
        "Connect to https://www.evil.malicious.com on port 443",
        "Command and control server: https://www.malicious.anonymous.com",
        "Backup C2: evil.malicious.com",
        "Secondary domain: fake.hacker.com",
        "Malicious site: malicious.anonymous.com",
        "Download from http://backdoor.evil.org/payload",
        "Trojan server: trojan.hacker.net",
        "Botnet C2: botnet.malicious.com",
        "fake.hacker.com",
        "evil.malicious.com",
        "malicious.anonymous.com",
        "backdoor.evil.org",
        "trojan.hacker.net",
        "botnet.malicious.com"
    ]
    
    for ip in attack_ip_addr:
        try:
            os.system(f"ping -n 1 {ip}")
        except Exception as e:
            print(f"Ping failed for {ip}: {e}")
    
    for domain in hacker_domain:
        try:
            subprocess.Popen(["curl", "-s", "--connect-timeout", "1", domain], 
                           stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except Exception as e:
            print(f"Network simulation failed for {domain}: {e}")
    
    print(f"Network data embedded: {len(hacker_domain_commands)} indicators")
    
    return {
        "domains": hacker_domain + hacker_domain_commands,
        "ips": attack_ip_addr
    }

def embed_suspicious_arguments():
    """
    description: Embeds malware keywords and suspicious command-line arguments for threat detection testing
    parameters: None
    returns: dict containing keywords list with embedded malicious terminology
    """
    suspicious_keywords = [
        "ransomware", "keylogger", "backdoor", "shellcode", "exploit", "virus", 
        "trojan", "worm", "malware", "spyware", "adware", "phishing", "botnet",
        "This is a ransomware payload",
        "Keylogger initialization complete", 
        "Backdoor established successfully",
        "Shellcode injection ready",
        "Exploit payload loaded",
        "Virus signature: malware.trojan.win32",
        "Worm propagation module",
        "Spyware data collection active"
    ]
    
    suspicious_arguments = ["--infect", "--payload", "--virus", "--encrypt", "--decrypt", "--backdoor"]
    if any(arg in sys.argv for arg in suspicious_arguments):
        pass
    
    print(f"Suspicious keywords embedded: {len(suspicious_keywords)} indicators")
    
    return {
        "keywords": suspicious_keywords
    }

def embed_injection_apis():
    """
    description: Embeds Windows API functions commonly used for process injection and code manipulation
    parameters: None
    returns: dict containing injection_apis list with process manipulation function names
    """
    injection_apis = [
        "VirtualAllocEx", "WriteProcessMemory", "CreateRemoteThread", "OpenProcess",
        "SetThreadContext", "NtUnmapViewOfSection", "LoadLibraryA", "GetProcAddress"
    ]

    return {
        "injection_apis": injection_apis
    }

def embed_registry_commands():
    """
    description: Embeds registry persistence mechanisms and creates actual registry entries for malware analysis
    parameters: None
    returns: dict containing registry_paths list with Windows persistence locations
    """
    registry_key = r"Software\Microsoft\Windows\CurrentVersion\Run"

    embedded_registry_paths = [
        "Registry key: Software\\Microsoft\\Windows\\CurrentVersion\\Run",
        "Persistence location: HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
        "Autostart registry path: CurrentVersion\\Run",
        "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
        "Registry persistence: Software\\Microsoft\\Windows\\CurrentVersion\\Run",
        "Persistence location: HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"
    ]

    print(f"Registry paths embedded: {len(embedded_registry_paths)} indicators")
    
    key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, registry_key, 0, winreg.KEY_SET_VALUE)
    winreg.SetValueEx(key, "Updater", 0, winreg.REG_SZ, os.path.abspath(__file__))
    winreg.CloseKey(key)
    
    key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, r"Software\\TestKey")
    winreg.SetValueEx(key, "TestValue", 0, winreg.REG_SZ, "Test")
    winreg.CloseKey(key)
    
    return {
        "registry_paths": [registry_key] + embedded_registry_paths
    }

def embed_powershell_commands():
    """
    description: Embeds obfuscated PowerShell commands and executes encoded payloads for behavioral analysis
    parameters: None
    returns: dict containing powershell_commands list with encoded and malicious PowerShell scripts
    """
    # Embed PowerShell commands directly in this function
    powershell_command = 'powershell -nop -w hidden -enc aGVsbG8gd29ybGQ='
    embedded_powershell_cmommands = [
        "powershell -nop -w hidden -enc aGVsbG8gd29ybGQ=",
        "powershell -encodedcommand JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0AA==",
        "powershell.exe -ExecutionPolicy Bypass -Command",
        "powershell -encodedcommand cwBlAHQALQBlAHgAZQBjAHUAdABpAG8AbgBwAG8AbABpAGMAeQAgAGIAeQBwAGEAcwBzAA==",
        "Malicious PowerShell: powershell -nop -w hidden -enc aGVsbG8gd29ybGQ=",
        "Encoded command: powershell -encodedcommand aWV4IChuZXctb2JqZWN0IG5ldC53ZWJjbGllbnQp"
    ]
    
    subprocess.Popen(powershell_command, shell=True)
    
    print(f"PowerShell commands embedded: {len(embedded_powershell_cmommands)} indicators")
    
    return {
        "powershell_commands": [powershell_command] + embedded_powershell_cmommands
    }


def embed_suspicious_markers():
    """
    description: Embeds YARA rules, EICAR signatures, suspicious files, and high-entropy Base64 strings for detection testing
    parameters: None
    returns: dict containing yara_patterns, suspicious_files, base64_strings, eicar_signature, eicar_base64, and pe_header
    """
    yara_pattern = "rule ransomware_example { strings: $a = \"READ_ME.txt\" $b = \"encrypted\" condition: $a and $b }"

    embedded_yara_patterns = [
        "rule malware_detection { strings: $a = \"malicious\" condition: $a }",
        "rule trojan_behavior { strings: $b = \"backdoor\" condition: $b }",
        "rule ransomware_pattern { strings: $c = \"encrypt\" condition: $c }",
        "rule suspicious_behavior { strings: $a = \"backdoor\" $b = \"keylogger\" condition: any of them }",
        "YARA rule detected: rule ransomware_example",
        "Pattern match: rule malware_detection"
    ]
    
    malware_marker = "[Section:MalwareConfig]\nkey=secret\n"
    high_entropy = "dGhpc2lzYXJlbG9uZ2hpZ2hlbnRyb3B5c3RyaW5n"  # base64
    
    suspicious_files = [
        "wannacry.exe", "evil.dll", "payload.bin", "exploit.sys", "iloveyou.exe", "stuxnet.bin",
        "Dropping file: wannacry.exe",
        "Loading library: evil.dll",
        "Creating payload: payload.bin", 
        "Installing driver: exploit.sys",
        "Malware executable: iloveyou.exe",
        "Threat file: stuxnet.bin"
    ]
    
    embedded_base64_strings = [
        "aGVsbG8gd29ybGQ=",
        "d2FubmFjcnkuZXhl",
        "UmFuc29td2FyZSBwYXlsb2Fk",
        "Base64 encoded payload: aGVsbG8gd29ybGQ=",
        "Encoded string: d2FubmFjcnkuZXhl",
        "Hidden data: UmFuc29td2FyZSBwYXlsb2Fk",
        "Base64 payload: dGhpc2lzYXJlbG9uZ2hpZ2hlbnRyb3B5c3RyaW5n",
        "Encoded command: aGVsbG8gd29ybGQ=",
        "Encrypted data: VGhpcyBpcyBhIHRlc3QgbWVzc2FnZSBmb3IgZW5jcnlwdGlvbg=="
    ]
    
    # EICAR signature
    eicar_bytes = b"X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"
    eicar_base64 = base64.b64encode(eicar_bytes).decode()
    
    print(yara_pattern)
    print(malware_marker)
    print(high_entropy)
    
    print(f"YARA patterns embedded: {len(embedded_yara_patterns)} indicators")
    print(f"Suspicious files embedded: {len(suspicious_files)} indicators")
    print(f"Base64 strings embedded: {len(embedded_base64_strings)} indicators")
    
    return {
        "yara_patterns": [yara_pattern] + embedded_yara_patterns,
        "suspicious_files": suspicious_files,
        "base64_strings": [high_entropy] + embedded_base64_strings,
        "eicar_signature": eicar_bytes,
        "eicar_base64": eicar_base64,
        "pe_header": b"MZ\x90\x00\x03\x00\x00\x00\x04\x00\x00\x00\xff\xff\x00\x00"
    }

def embed_suspicious_content():
    """
    description: Orchestrates all malware indicator embedding functions and consolidates results into comprehensive dataset
    parameters: None
    returns: tuple containing (embedded_data dict, all_embedded_strings list) with complete malware indicators
    """
    network_data = embed_suspicious_network_markers()
    keyword_data = embed_suspicious_arguments()
    injection_data = embed_injection_apis()
    registry_data = embed_registry_commands()
    powershell_data = embed_powershell_commands()
    misc_data = embed_suspicious_markers()
    
    # Create a comprehensive embedded data structue using returned data
    embedded_data = {
        "pe_header": misc_data["pe_header"],
        "eicar_signature": misc_data["eicar_signature"],
        "malicious_domains": network_data["domains"],
        "attack_ips": network_data["ips"],
        "malicious_keywords": keyword_data["keywords"],
        "injection_apis": injection_data["injection_apis"],
        "powershell_commands": powershell_data["powershell_commands"],
        "registry_paths": registry_data["registry_paths"],
        "yara_patterns": misc_data["yara_patterns"],
        "suspicious_files": misc_data["suspicious_files"],
        "high_entropy_strings": misc_data["base64_strings"],
        "base64_eicar": misc_data["eicar_base64"]
    }
    
    all_embedded_strings = []
    for category, items in embedded_data.items():
        if isinstance(items, list):
            all_embedded_strings.extend([str(item) for item in items])
        else:
            all_embedded_strings.append(str(items))
    
    return embedded_data, all_embedded_strings

def execute_malware_attack():
    """
    description: Main malware simulation function that forces all indicators into binary and displays comprehensive analysis output
    parameters: None
    returns: int representing total size of embedded malicious content in bytes
    """
    embedded_data, all_strings = embed_suspicious_content()
    
    binary_strings = []
    for category, items in embedded_data.items():
        if isinstance(items, list):
            binary_strings.extend([str(item) for item in items])
        elif isinstance(items, bytes):
            binary_strings.append(items.decode('utf-8', errors='ignore'))
        else:
            binary_strings.append(str(items))
    
    embedded_binary_data = b"\x00".join([s.encode('utf-8', errors='ignore') for s in binary_strings]) + b"\x00"
    forced_strings = "\n".join(binary_strings)
    binary_data = forced_strings.encode('utf-8', errors='ignore')
    embedded_binary_size = len(embedded_binary_data)
    eicar_binary = embedded_data.get('eicar_signature', b"X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*")
    total_embedded_size = len(forced_strings) + len(str(embedded_data)) + len(binary_data) + len(eicar_binary) + embedded_binary_size
    
    print("=" * 60)
    print("STATIC MALWARE TRIGGER - ACADEMIC USE ONLY")
    print("=" * 60)
    print("This executable contains embedded malware indicators for testing static analysis tools.")
    print(f"Embedded domains: {len(embedded_data['malicious_domains'])}")
    print(f"Embedded IPs: {len(embedded_data['attack_ips'])}")
    print(f"Embedded keywords: {len(embedded_data['malicious_keywords'])}")
    print(f"Embedded injection APIs: {len(embedded_data['injection_apis'])}")
    print(f"Embedded PowerShell commands: {len(embedded_data['powershell_commands'])}")
    print(f"Embedded registry paths: {len(embedded_data['registry_paths'])}")
    print(f"Embedded YARA patterns: {len(embedded_data['yara_patterns'])}")
    print(f"Embedded suspicious files: {len(embedded_data['suspicious_files'])}")
    print(f"Embedded base64 strings: {len(embedded_data['high_entropy_strings'])}")
    print(f"Total embedded strings: {len(all_strings)}")
    print(f"Forced embedded data size: {total_embedded_size} bytes")
    print("=" * 60)
    print("Ready for static analysis testing.")
    print("=" * 60)
    
    print("\n=== FORCING ALL STRINGS TO BE EMBEDDED ===")
    print("Domains that MUST be detected:")
    for domain in embedded_data['malicious_domains']:
        print(f"DOMAIN: {domain}")
    
    print("\nIPs that MUST be detected:")
    for ip in embedded_data['attack_ips']:
        print(f"IP: {ip}")
    
    print("\nKeywords that MUST be detected:")
    for keyword in embedded_data['malicious_keywords']:
        print(f"KEYWORD: {keyword}")
    
    print("\nInjection APIs that MUST be detected:")
    for api in embedded_data['injection_apis']:
        print(f"API: {api}")
    
    print("\nPowerShell commands that MUST be detected:")
    for ps_cmd in embedded_data['powershell_commands']:
        print(f"POWERSHELL: {ps_cmd}")
    
    print("\nRegistry paths that MUST be detected:")
    for reg_path in embedded_data['registry_paths']:
        print(f"REGISTRY: {reg_path}")
    
    print("\nSuspicious files that MUST be detected:")
    for file_name in embedded_data['suspicious_files']:
        print(f"FILE: {file_name}")
    
    print("\nYARA patterns that MUST be detected:")
    for yara_pattern in embedded_data['yara_patterns']:
        print(f"YARA: {yara_pattern}")
    
    print("\nBase64 strings that MUST be detected:")
    for base64_str in embedded_data['high_entropy_strings']:
        print(f"BASE64: {base64_str}")
    
    print("\nEICAR signature embedded as binary data:")
    print(f"EICAR_BYTES: {eicar_binary}")
    print(f"EICAR_LENGTH: {len(eicar_binary)}")
    
    print(f"\nBinary data size: {len(binary_data)} bytes")
    print(f"Binary data sample: {binary_data[:100]}")
    print(f"Embedded binary data size: {embedded_binary_size} bytes")
    print(f"Embedded binary data sample: {embedded_binary_data[:100]}")
    
    print(f"\nForced binary embedding verification:")
    test_data = embedded_binary_data[100:200] if len(embedded_binary_data) > 200 else embedded_binary_data  # Use a slice to force reference
    print(f"Binary test data: {test_data}")
    
    print(f"\nConstants still embedded:")
    print(f"All domains: {len(embedded_data['malicious_domains'])}")
    print(f"All IPs: {len(embedded_data['attack_ips'])}")
    print(f"All keywords: {len(embedded_data['malicious_keywords'])}")
    print(f"All injection APIs: {len(embedded_data['injection_apis'])}")
    print(f"All PowerShell: {len(embedded_data['powershell_commands'])}")
    print(f"All registry: {len(embedded_data['registry_paths'])}")
    print(f"All files: {len(embedded_data['suspicious_files'])}")
    print(f"All YARA: {len(embedded_data['yara_patterns'])}")
    print(f"All Base64: {len(embedded_data['high_entropy_strings'])}")
    
    print("\n=== ALL STRINGS FORCED TO BE EMBEDDED ===")
    print("All suspicious content is now embedded in this executable's binary.")
    print("No external files are created.")
    print("Use this executable as input to your malware analysis tool.")
    
    return total_embedded_size + len(binary_data) + len(eicar_binary) + embedded_binary_size + len(test_data)


def execute_powershell():
    """
    description: Executes PowerShell commands and creates files to simulate MITRE ATT&CK technique T1059
    parameters: None
    returns: None
    """
    os.system('powershell -Command "Write-Host HelloWorld"')  # Simulates T1059
    with open("harmless.txt", "w") as file:
        file.write("This is a harmless file for AV and MITRE ATT&CK testing.\n")


def execute_registry():
    """
    description: Creates registry entries for persistence testing and behavioral analysis detection
    parameters: None
    returns: None
    """
    try:
        key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, r"Software\\TestKey")
        winreg.SetValueEx(key, "TestValue", 0, winreg.REG_SZ, "Test")
        winreg.CloseKey(key)
    except Exception as e:
        pass  # Ignore on non-Windows


if __name__ == "__main__":
    # Execute all embedding functions to ensure indicators are in memory
    embed_suspicious_network_markers()
    embed_suspicious_arguments()
    embed_injection_apis()
    embed_registry_commands()
    embed_powershell_commands()
    embed_suspicious_markers()
    
    # Execute main malware simulation
    size = execute_malware_attack()
    
    # Execute behavioral functions
    execute_powershell()
    execute_registry()
    
    if size > 0:
        print(f"\nSuccessfully embedded {size} bytes of suspicious content.")
        print("This executable now contains all the malware indicators needed for testing.")
        print("Every string has been forced to be embedded in the binary.")
        print("All static analysis functions were called to ensure indicator embedding.")
