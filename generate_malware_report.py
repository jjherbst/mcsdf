"""
static_reporter_pdf.py
----------------------
Academic reporting tool: Extracts static malware indicators from a Windows EXE/DLL file.
Outputs a visually professional PDF report.
"""

import sys
import datetime
import hashlib
import re
import base64
import pefile
from pdf_report import pdf_report
from pathlib import Path
from math import log2

# === Analysis Patterns and Thresholds ===

SUSPICIOUS_KEYWORDS = [
    "ransomware",
    "keylogger",
    "backdoor",
    "shellcode",
    "exploit",
    "virus",
    "trojan",
    "worm",
    "malware",
    "spyware",
    "adware",
    "phishing",
    "botnet",
    "exploit kit",
    "rootkit",
    "DDoS attack",
    "SQL injection",
    "XSS attack",
    "command injection",
    "buffer overflow",
]

SUSPICIOUS_DOMAINS = [
    r"fake\.hacker\.com",
    r"haxor\-c2\.example\.net",
    r"evil\.malicious\.com",
    r"malicious\.anonymous\.com",
    r"c2\..*\.com",
    r"evil\.[a-zA-Z0-9\-]+\.(com|net|org)",
    r"malicious\.[a-zA-Z0-9\-]+\.(com|net|org)",
    r"hacker\.[a-zA-Z0-9\-]+\.(com|net|org)",
    r"backdoor\.[a-zA-Z0-9\-]+\.(com|net|org)",
    r"trojan\.[a-zA-Z0-9\-]+\.(com|net|org)",
    r"botnet\.[a-zA-Z0-9\-]+\.(com|net|org)"
]

SUSPICIOUS_FILENAMES = [
    "wannacry.exe",
    "evil.dll",
    "payload.bin",
    "exploit.sys",
    "iloveyou",
    "stuxnet",
    "zues"
]

IP_REGEX = r"(?:[0-9]{1,3}\.){3}[0-9]{1,3}"

POWERSHELL_REGEX = r"powershell.+?(?:\-enc|\-encodedcommand)"

REGISTRY_PATH_REGEX = r"Software\\Microsoft\\Windows\\CurrentVersion\\Run"

YARA_RULE_REGEX = r"rule\s+\w+\s*\{[^}]+\}"

EICAR_SIGNATURE = (
    b"X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"
)

HIGH_ENTROPY_THRESHOLD = 4.5


# === Utility Functions ===
def extract_ascii_strings_from_binary(binary_data, min_length=6):
    # rb = raw binary string
    # 0x20 to 0x7E which are the standard printable ASCII characters
    pattern = rb"[\x20-\x7E]{%d,}" % min_length
    ascii_strings = re.findall(pattern, binary_data)
    decoded_strings = [s.decode("ascii", errors="ignore") for s in ascii_strings]
    return decoded_strings


def detect_base64_encoded_strings(string_list, min_length=16):
    decoded_results = []
    for string_candidate in string_list:
        if len(string_candidate) >= min_length and re.fullmatch(
            r"[A-Za-z0-9+/=]+", string_candidate
        ):
            try:
                decoded_bytes = base64.b64decode(
                    string_candidate, validate=True)
                decoded_results.append((string_candidate, decoded_bytes[:32]))
            except Exception:
                continue
    return decoded_results


def calculate_shannon_entropy(byte_sequence):
    if isinstance(byte_sequence, str):
        byte_sequence = byte_sequence.encode()
    if not byte_sequence:
        return 0.0
    frequency_table = [0] * 256
    for byte in byte_sequence:
        frequency_table[byte] += 1
    entropy = 0.0
    for byte_count in frequency_table:
        if byte_count:
            probability = byte_count / len(byte_sequence)
            entropy -= probability * log2(probability)
    return entropy


def detect_high_entropy_sections(
    binary_data, window_size=256, entropy_threshold=HIGH_ENTROPY_THRESHOLD
):
    suspicious_chunks = []
    for offset in range(0, len(binary_data) - window_size, window_size):
        chunk = binary_data[offset: offset + window_size]
        entropy = calculate_shannon_entropy(chunk)
        if entropy >= entropy_threshold:
            suspicious_chunks.append((offset, entropy))
    return suspicious_chunks


def detect_pe_headers(file_path):
    # Create a copy of the file path to avoid modifying the original
    pe_file_path = file_path
    
    # If file is .pyc, replace with .exe and look in bin folder
    if file_path.endswith('.pyc'):
        filename = Path(file_path).stem + '.exe'
        pe_file_path = f'./bin/{filename}'
        print(f"Converting .pyc to .exe: {pe_file_path}")
    
    try:
        pe = pefile.PE(pe_file_path)
        return {
            "entry_point": hex(getattr(pe.OPTIONAL_HEADER, "AddressOfEntryPoint", 0)),
            "image_base": hex(getattr(pe.OPTIONAL_HEADER, "ImageBase", 0)),
            "sections": [
                (
                    section.Name.decode(errors="ignore").strip("\x00"),
                    hex(section.VirtualAddress),
                    hex(section.Misc_VirtualSize),
                )
                for section in pe.sections
            ],
        }
    except pefile.PEFormatError:
        return {
            "entry_point": "N/A (Not a valid PE file)",
            "image_base": "N/A (Not a valid PE file)",
            "sections": [("N/A", "N/A", "N/A")],
        }


def detect_file_information(file_path):
    file_object = Path(file_path)
    file_bytes = file_object.read_bytes()
    info = {
        "File Name": str(file_object.name),
        "File Size": f"{file_object.stat().st_size:,} bytes",
        "SHA256": hashlib.sha256(file_bytes).hexdigest(),
        "MD5": hashlib.md5(file_bytes).hexdigest(),
        "SHA1": hashlib.sha1(file_bytes).hexdigest(),
    }
    try:
        info["Created"] = datetime.datetime.fromtimestamp(
            file_object.stat().st_ctime
        ).isoformat()
        info["Modified"] = datetime.datetime.fromtimestamp(
            file_object.stat().st_mtime
        ).isoformat()
    except OSError:
        pass
    return info


def detect_suspicious_file_names(file_path, ascii_strings):
    file_object = Path(file_path)
    filename_matches = []
    embedded_matches = []

    for suspicious_name in SUSPICIOUS_FILENAMES:
        # Check if suspicious name is in the actual filename
        if suspicious_name.lower() in file_object.name.lower():
            filename_matches.append(suspicious_name)

        # Check if suspicious name is embedded in the file content
        elif any(suspicious_name.lower() in string.lower() for string in ascii_strings):
            embedded_matches.append(suspicious_name)

    return {
        "found": bool(filename_matches or embedded_matches),
        "filename_matches": filename_matches,
        "embedded_matches": embedded_matches
    }


def detect_suspicious_keywords(ascii_strings):
    combined_strings = ascii_strings
    
    keywords_detected = []
    total_matches = 0

    for keyword in SUSPICIOUS_KEYWORDS:
        matches = [string for string in combined_strings if keyword.lower()
                   in string.lower()]
        if matches:
            keywords_detected.append(keyword)
            total_matches += len(matches)

    return {
        "found": bool(keywords_detected),
        "keywords_detected": keywords_detected,
        "total_matches": total_matches
    }


def detect_suspicious_domains(ascii_strings):
    all_strings = ascii_strings
    
    found_domains = set()  # Use set to avoid duplicates
    total_matches = 0

    # Join all strings for comprehensive search
    all_text = " ".join(all_strings)

    # Method 1: Direct pattern matching in individual strings
    for domain_pattern in SUSPICIOUS_DOMAINS:
        for string in all_strings:
            matches = re.findall(domain_pattern, string, re.IGNORECASE)
            for match in matches:
                found_domains.add(
                    f"{string[:50]}")
                total_matches += 1

    # Method 2: Extract URLs (http/https) and check domains
    url_pattern = r'https?://(?:www\.)?([a-zA-Z0-9\-\.]+\.[a-zA-Z]{2,})'
    urls = re.findall(url_pattern, all_text, re.IGNORECASE)
    for url_domain in urls:
        # Check if extracted domain matches any suspicious pattern
        for domain_pattern in SUSPICIOUS_DOMAINS:
            if re.search(domain_pattern, url_domain, re.IGNORECASE):
                found_domains.add(f"{url_domain}")
                total_matches += 1
                break
        # Also check for suspicious keywords in domain names
        suspicious_keywords = ['evil', 'malicious', 'fake',
                               'hacker', 'c2', 'backdoor', 'trojan', 'botnet']
        if any(keyword in url_domain.lower() for keyword in suspicious_keywords):
            found_domains.add(f"{url_domain}")
            total_matches += 1

    # Method 3: General domain extraction (without protocol)
    domain_pattern = r'\b([a-zA-Z0-9\-]+\.(?:com|net|org|info|biz|co|io|me|tk|ml|ga|cf))\b'
    domains = re.findall(domain_pattern, all_text, re.IGNORECASE)
    for domain in domains:
        # Check against suspicious patterns
        for suspicious_pattern in SUSPICIOUS_DOMAINS:
            if re.search(suspicious_pattern, domain, re.IGNORECASE):
                found_domains.add(f"Domain: {domain}")
                total_matches += 1
                break
        # Check for suspicious keywords in domain
        suspicious_keywords = ['evil', 'malicious', 'fake',
                               'hacker', 'c2', 'backdoor', 'trojan', 'botnet']
        if any(keyword in domain.lower() for keyword in suspicious_keywords):
            found_domains.add(f"{domain}")
            total_matches += 1

    return {
        "found": bool(found_domains),
        "domains_detected": sorted(list(found_domains)),
        "total_matches": total_matches
    }


def detect_ip_addresses(ascii_strings):
    all_strings_joined = " ".join(ascii_strings)
    ip_addresses_set = set(re.findall(IP_REGEX, all_strings_joined))
    # Sort for consistent output
    ip_addresses_list = sorted(list(ip_addresses_set))

    return {
        "found": bool(ip_addresses_list),
        "ip_addresses": ip_addresses_list,
        "total_matches": len(ip_addresses_list)
    }


def detect_powershell_commands(ascii_strings):
    powershell_commands = [
        string
        for string in ascii_strings
        if re.search(POWERSHELL_REGEX, string, re.IGNORECASE)
    ]

    return {
        "found": bool(powershell_commands),
        "powershell_commands": powershell_commands,
        "total_matches": len(powershell_commands)
    }


def detect_registry_paths(ascii_strings):
    registry_paths = [
        string for string in ascii_strings if re.search(REGISTRY_PATH_REGEX, string)
    ]

    return {
        "found": bool(registry_paths),
        "registry_paths": registry_paths,
        "total_matches": len(registry_paths)
    }


def detect_yara_patterns(ascii_strings):
    yara_patterns = [
        string for string in ascii_strings if re.search(YARA_RULE_REGEX, string)
    ]

    return {
        "found": bool(yara_patterns),
        "yara_patterns": yara_patterns,
        "total_matches": len(yara_patterns)
    }


def detect_eicar_signature(binary_data):
    signature_found = EICAR_SIGNATURE in binary_data

    return {
        "found": signature_found,
        "signature_detected": signature_found,
        "signature_info": "EICAR test signature detected!" if signature_found else "No EICAR test signature detected"
    }


# === Reporting Section Functions ===
def write_file_information(pdf, file_path):
    pdf.section_title("File Information")
    fileinfo = detect_file_information(file_path)
    pdf.value_table(fileinfo)


def write_pe_header(pdf, file_path):
    pdf.section_title("PE Metadata")
    peinfo = detect_pe_headers(file_path)
    for key, value in peinfo.items():
        if key == "sections":
            pdf.set_font("Arial", "B", 10)
            pdf.cell(0, 7, "Sections:", ln=True)
            pdf.set_font("Arial", "", 10)
            for section in value:
                pdf.cell(8)
                pdf.cell(
                    0,
                    7,
                    f"Name: {section[0]}, VA: {section[1]}, Size: {section[2]}",
                    ln=True,
                )
            pdf.ln(1)
        else:
            pdf.cell(30, 7, f"{key.replace('_', ' ').title()}:", border=0)
            pdf.cell(0, 7, str(value), ln=True)


def write_suspicious_filenames(pdf, file_path, ascii_strings):
    pdf.section_title("Suspicious Filenames")
    detection_results = detect_suspicious_file_names(file_path, ascii_strings)

    if detection_results["found"]:
        # Report filename matches
        for suspicious_name in detection_results["filename_matches"]:
            pdf.item_list(
                [f"File name matches suspicious pattern: {suspicious_name}"],
                color=(220, 90, 90),
            )

        # Report embedded matches
        for suspicious_name in detection_results["embedded_matches"]:
            pdf.item_list(
                [f"{suspicious_name}"],
                color=(190, 100, 100),
            )
    else:
        pdf.highlight_text(
            "No suspicious file names detected in file name or content.")


def write_suspicious_keywords(pdf, ascii_strings):
    pdf.section_title("Suspicious Keywords")
    detection_results = detect_suspicious_keywords(ascii_strings)

    if detection_results["found"]:
        pdf.item_list(
            [f"{keyword}" for keyword in detection_results["keywords_detected"]],
            color=(210, 70, 70),
        )
    else:
        pdf.highlight_text("No suspicious keywords detected.")


def write_suspicious_domains(pdf, ascii_strings):
    pdf.section_title("Suspicious Domains")
    detection_results = detect_suspicious_domains(ascii_strings)

    if detection_results["found"]:
        pdf.item_list(
            detection_results["domains_detected"], color=(170, 120, 70))
    else:
        pdf.highlight_text("No suspicious domains detected.")


def write_ip_addresses(pdf, ascii_strings):
    pdf.section_title("IP Addresses")
    detection_results = detect_ip_addresses(ascii_strings)

    if detection_results["found"]:
        pdf.item_list(detection_results["ip_addresses"], color=(25, 25, 120))
    else:
        pdf.highlight_text("No IP addresses detected.")


def write_powershell_commands(pdf, ascii_strings):
    pdf.section_title("Powershell Commands")
    detection_results = detect_powershell_commands(ascii_strings)

    if detection_results["found"]:
        pdf.item_list(
            [f"{cmd}" for cmd in detection_results["powershell_commands"]],
            color=(100, 80, 200)
        )
    else:
        pdf.highlight_text("No suspicious PowerShell commands detected.")


def write_registry_paths(pdf, ascii_strings):
    pdf.section_title("Registry Paths")
    detection_results = detect_registry_paths(ascii_strings)

    if detection_results["found"]:
        pdf.item_list(
            [f"{reg_path}" for reg_path in detection_results["registry_paths"]],
            color=(90, 140, 120),
        )
    else:
        pdf.highlight_text("No suspicious registry paths detected.")


def write_yara_patterns(pdf, ascii_strings):
    pdf.section_title("YARA-like Rules")
    detection_results = detect_yara_patterns(ascii_strings)

    if detection_results["found"]:
        pdf.item_list(
            [f"{rule}" for rule in detection_results["yara_patterns"]],
            color=(100, 110, 190)
        )
    else:
        pdf.highlight_text("No YARA-like rules detected.")


def write_eicar_signature(pdf, binary_data):
    pdf.section_title("EICAR Signature")
    detection_results = detect_eicar_signature(binary_data)
    if detection_results["found"]:
        pdf.item_list(["EICAR test signature detected!"], color=(200, 30, 30))
    else:
        pdf.highlight_text("No EICAR test signature detected.")


def write_base64_strings(pdf, ascii_strings):
    pdf.section_title("Base64-Encoded Strings")
    base64_results = detect_base64_encoded_strings(ascii_strings)
    if base64_results:
        for base64_string, decoded_content in base64_results:
            # Convert binary data to safe ASCII representation
            preview = str(decoded_content[:32]).replace(
                "\u2022", "*").replace("•", "*")
            # Ensure all characters are ASCII
            safe_preview = preview.encode("ascii", "replace").decode("ascii")
            safe_base64 = base64_string[:30].encode(
                "ascii", "replace").decode("ascii")
            pdf.item_list(
                [
                    f"{safe_base64}... Decoded: [{safe_preview}]"
                ],
                color=(80, 100, 150),
            )
    else:
        pdf.highlight_text("No base64-encoded strings detected.")


def write_high_entropy_sections(pdf, binary_data):
    pdf.section_title("High Entropy Sections")
    high_entropy_chunks = detect_high_entropy_sections(binary_data)
    if high_entropy_chunks:
        for offset, entropy_value in high_entropy_chunks[:10]:
            pdf.item_list(
                [f"Offset {hex(offset)} - Entropy: {entropy_value:.2f}"],
                color=(110, 70, 170),
            )
    else:
        pdf.highlight_text(
            "No high-entropy (packed/obfuscated) sections detected.")


def write_ascii_strings(pdf, ascii_strings, columns=3):
    pdf.section_title("All ASCII Strings (First 100")
    max_strings = 100
    display_strings = (
        ascii_strings[:max_strings]
        if len(ascii_strings) > max_strings
        else ascii_strings
    )

    pdf.set_font("Arial", "", 7)
    col_width = (pdf.w - 2 * pdf.l_margin) / columns
    pdf.set_fill_color(245, 245, 245)
    pdf.set_text_color(40, 40, 40)

    # Arrange into rows of 4 columns
    rows = [
        display_strings[i: i + columns]
        for i in range(0, len(display_strings), columns)
    ]
    for row in rows:
        for col in range(columns):
            val = row[col] if col < len(row) else ""
            pdf.cell(col_width, 4, val, border=0, align="L", fill=True)
        pdf.ln(4)

    pdf.set_text_color(0, 0, 0)
    pdf.set_font("Arial", "", 10)
    if len(ascii_strings) > max_strings:
        pdf.highlight_text(
            f"...{len(ascii_strings)-max_strings} more strings omitted for brevity."
        )


def generate_static_report_pdf(file_path, pdf_path="static_report.pdf"):
    with open(file_path, "rb") as binary_file:
        binary_data = binary_file.read()

    ascii_strings = extract_ascii_strings_from_binary(binary_data)

    pdf = pdf_report()
    pdf.add_page()

    # Header & Meta
    pdf.section_title(f"Malware Analysis Report: {Path("file_path").name}")
    pdf.highlight_text(
        f"Date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        "All results are for demonstration and academic research only.\n"
    )

    write_file_information(pdf, file_path)
    write_pe_header(pdf, file_path)
    write_suspicious_filenames(pdf, file_path, ascii_strings)
    write_suspicious_keywords(pdf, ascii_strings)
    write_suspicious_domains(pdf, ascii_strings)
    write_ip_addresses(pdf, ascii_strings)
    write_powershell_commands(pdf, ascii_strings)
    write_registry_paths(pdf, ascii_strings)
    write_yara_patterns(pdf, ascii_strings)
    write_eicar_signature(pdf, binary_data)
    write_base64_strings(pdf, ascii_strings)
    write_high_entropy_sections(pdf, binary_data)
    write_ascii_strings(pdf, ascii_strings)

    pdf.output(pdf_path)
    print(f"PDF Report written to {pdf_path}")


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(
            "Usage: python static_reporter_pdf.py <target_exe> [output_report.pdf]")
    else:
        output_pdf_path = sys.argv[2] if len(
            sys.argv) >= 3 else "static_report.pdf"
        generate_static_report_pdf(sys.argv[1], output_pdf_path)
