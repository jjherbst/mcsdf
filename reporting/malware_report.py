#!/usr/bin/env python3
import argparse
import asyncio
import os
import sys
from datetime import datetime as dt
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from math import log2

# Handle imports for both module and standalone execution
# Add the parent directory to sys.path so we can import from reporting package
script_dir = Path(__file__).parent.resolve()
parent_dir = script_dir.parent
if str(parent_dir) not in sys.path:
    sys.path.insert(0, str(parent_dir))

from .patterns import (
    SUSPICIOUS_KEYWORDS,
    SUSPICIOUS_DOMAINS,
    SUSPICIOUS_FILENAMES,
    IP_REGEX,
    POWERSHELL_REGEX,
    REGISTRY_PATH_REGEX,
    YARA_RULE_REGEX,
    EICAR_SIGNATURE,
    HIGH_ENTROPY_THRESHOLD,
)
from .pdf_report import MalwareAnalysisReport
from .virus_total_analyzer import VirusTotalAnalyzer
from .malware_analyzer import MalwareAnalyzer

async def generate_comprehensive_report(pyc_file_path: Path, exe_file_path: Path, output_path: Path, api_key: Optional[str] = None, skip_vt: bool = False, exe_exists: bool = True) -> bool:
    """Generate comprehensive malware analysis report."""
    try:
        print(f"=== Starting Comprehensive Malware Analysis ===")
        print(f" Analyzing Python file: {pyc_file_path.name}")
        if exe_exists:
            print(f" Executable available for VirusTotal: {exe_file_path.name}")
        
        # Read file data from .pyc file for static analysis
        with open(pyc_file_path, 'rb') as f:
            binary_data = f.read()
        
        # Extract strings from .pyc file
        analyzer = MalwareAnalyzer()
        ascii_strings = analyzer.extract_ascii_strings(binary_data)
        print(f" Extracted {len(ascii_strings)} ASCII strings from {pyc_file_path.name}")
        
        # Perform static analysis on .pyc file
        print(f" Performing static analysis on {pyc_file_path.name}...")
        static_results = analyzer.analyze_static_indicators(pyc_file_path, binary_data, ascii_strings)
        
        # VirusTotal analysis on .exe file
        vt_results = None
        print(f"[DEBUG] VirusTotal analysis conditions:")
        print(f"[DEBUG]   skip_vt: {skip_vt}")
        print(f"[DEBUG]   api_key provided: {bool(api_key)}")
        print(f"[DEBUG]   exe_exists: {exe_exists}")
        print(f"[DEBUG]   exe_file_path: {exe_file_path}")
        
        if not skip_vt and api_key and exe_exists:
            print(f" Performing VirusTotal analysis on {exe_file_path.name}...")
            try:
                vt_analyzer = VirusTotalAnalyzer(api_key)
                vt_results = await vt_analyzer.analyze_file(exe_file_path)
                print(f"[DEBUG] VirusTotal analysis completed: {bool(vt_results)}")
                if vt_results:
                    print(f"[DEBUG] VirusTotal result keys: {list(vt_results.keys()) if isinstance(vt_results, dict) else 'Not a dict'}")
            except Exception as e:
                print(f"[ERROR] VirusTotal analysis failed: {e}")
                vt_results = None
        elif skip_vt:
            print(f" Skipping VirusTotal analysis as requested")
        elif not exe_exists:
            print(f" Skipping VirusTotal analysis (no executable file available)")
        else:
            print(f" Skipping VirusTotal analysis (no API key)")
        
        # Generate PDF report
        print(f" Generating comprehensive PDF report...")
        pdf = MalwareAnalysisReport()
        pdf.add_cover_page(pyc_file_path.name, dt.now().strftime("%B %d, %Y"))
        pdf.section_title("Executive Summary")
        # Count threats
        threat_count = 0
        threat_details = []
        
        if static_results["suspicious_keywords"]["found"]:
            threat_count += static_results["suspicious_keywords"]["total_matches"]
            threat_details.append(f"- {static_results['suspicious_keywords']['total_matches']} suspicious keywords detected")
        
        if static_results["suspicious_filenames"]["found"]:
            count = len(static_results["suspicious_filenames"]["filename_matches"]) + len(static_results["suspicious_filenames"]["embedded_matches"])
            threat_count += count
            threat_details.append(f"- {count} suspicious filename patterns found")
        
        if static_results["suspicious_domains"]["found"]:
            threat_count += static_results["suspicious_domains"]["total_matches"]
            threat_details.append(f"- {static_results['suspicious_domains']['total_matches']} suspicious domains found")
        
        if static_results["eicar_detected"]["found"]:
            threat_count += 1
            threat_details.append("- EICAR test signature detected")
        
        if vt_results:
            vt_stats = vt_results.get("data", {}).get("attributes", {}).get("last_analysis_stats", {})
            malicious = vt_stats.get("malicious", 0)
            suspicious = vt_stats.get("suspicious", 0)
            if malicious > 0 or suspicious > 0:
                threat_count += malicious + suspicious
                threat_details.append(f"- {malicious} malicious + {suspicious} suspicious VirusTotal detections")
        
        # Summary text
        if threat_count == 0:
            pdf.highlight_text("ANALYSIS RESULT: No significant threats detected.", (200, 255, 200))
        elif threat_count < 5:
            pdf.highlight_text(f"ANALYSIS RESULT: Low threat level - {threat_count} indicators found.", (255, 255, 200))
        else:
            pdf.highlight_text(f"ANALYSIS RESULT: High threat level - {threat_count} indicators found.", (255, 200, 200))
        
        if threat_details:
            pdf.item_list(threat_details)
        
        # Add file analysis information as bullet points
        analysis_notes = [f"Static analysis performed on: {pyc_file_path.name}"]
        if exe_exists and vt_results:
            analysis_notes.append(f"VirusTotal analysis performed on: {exe_file_path.name}")
        elif exe_exists:
            analysis_notes.append(f"Executable available but not analyzed: {exe_file_path.name}")
        else:
            analysis_notes.append("No executable file available for VirusTotal analysis")
        pdf.item_list(analysis_notes, color=(80, 80, 120))

        # === MCSDF STATIC ANALYSIS SECTION ===
        pdf.add_main_section_separator(
            "MCSDF Malware Analysis Report", 
            "CustomStatic Analysis Results"
        )
        # Force a new page so that all section content starts after the separator page
        pdf.add_page()
        # Generate all static analysis content
        _generate_static_analysis_section(pdf, static_results, pyc_file_path, ascii_strings)

        # === VIRUSTOTAL SECTION ===
        print(f"[DEBUG] Checking VirusTotal results for report inclusion...")
        print(f"[DEBUG] vt_results type: {type(vt_results)}")
        print(f"[DEBUG] vt_results is None: {vt_results is None}")
        print(f"[DEBUG] bool(vt_results): {bool(vt_results)}")
        
        if vt_results:
            print(f"[DEBUG] Adding VirusTotal section to report...")
            pdf.add_main_section_separator(
                "VirusTotal Analysis Results", 
                "External Threat Intelligence Results"
            )
            # Force a new page so that all section content starts after the separator page
            pdf.add_page()
            # Generate all VirusTotal content
            _generate_virustotal_section(pdf, vt_results, exe_file_path)
            print(f"[DEBUG] VirusTotal section added successfully")
        else:
            print(f"[DEBUG] VirusTotal section skipped - no results available")
        
        # === CONCLUSION ===
        pdf.section_title("Analysis Conclusion")

        # Build conclusion as bullet points
        conclusion_points = [
            f"Analysis completed on {dt.now().strftime('%Y-%m-%d %H:%M:%S')}."
        ]
        if threat_count == 0:
            conclusion_points.append("No significant malicious indicators were detected in this file.")
        elif threat_count < 5:
            conclusion_points.append(f"Low-level threat indicators detected ({threat_count} total). Further investigation may be warranted.")
        else:
            conclusion_points.append(f"High-level threat indicators detected ({threat_count} total). This file should be considered potentially malicious.")
        conclusion_points.append("This analysis is for educational and research purposes only.")
        pdf.item_list(conclusion_points, color=(120, 60, 60))
        
        # Save PDF
        pdf.output(str(output_path))
        print(f"Comprehensive report saved to: {output_path}")
        return True
        
    except Exception as error:
        print(f"Error generating report: {error}")
        return False


def _generate_static_analysis_section(pdf: MalwareAnalysisReport, static_results: Dict, pyc_file_path: Path, ascii_strings: List[str]):
    """Generate the complete MCSDF static analysis section."""
    
    # === FILE INFORMATION ===
    pdf.section_title("File Information")
    pdf.value_table(static_results["file_info"])
    
    # === PE HEADER INFORMATION ===
    pdf.section_title("PE Header Analysis")
    pe_info = static_results["pe_info"]
    pe_display = {k: v for k, v in pe_info.items() if k != "sections"}
    pdf.value_table(pe_display)
    
    if pe_info["sections"] and pe_info["sections"][0][0] != "N/A":
        pdf.set_font("Helvetica", "B", 10)
        pdf.cell(0, 7, "PE Sections:", new_x="LMARGIN", new_y="NEXT")
        pdf.set_font("Helvetica", "", 10)
        for section in pe_info["sections"]:
            pdf.cell(8)
            pdf.cell(0, 7, f"Name: {section[0]}, VA: {section[1]}, Size: {section[2]}", new_x="LMARGIN", new_y="NEXT")
        pdf.ln(1)
    
    # === STATIC ANALYSIS RESULTS ===
    pdf.section_title("Static Analysis Results")
    
    # Suspicious filenames
    if static_results["suspicious_filenames"]["found"]:
        pdf.section_title("Suspicious Filenames", "Filenames that may indicate malicious behavior")
        if static_results["suspicious_filenames"]["filename_matches"]:
            pdf.item_list([f"File name matches: {name}" for name in static_results["suspicious_filenames"]["filename_matches"]], color=(220, 90, 90))
        if static_results["suspicious_filenames"]["embedded_matches"]:
            pdf.item_list([f"{name}" for name in static_results["suspicious_filenames"]["embedded_matches"]], color=(190, 100, 100))
    
    # Suspicious keywords
    if static_results["suspicious_keywords"]["found"]:
        pdf.section_title("Suspicious Keywords Detected", "Keywords that may indicate malicious behavior")
        pdf.item_list(static_results["suspicious_keywords"]["keywords_detected"], color=(210, 70, 70))
    
    # Suspicious domains
    if static_results["suspicious_domains"]["found"]:
        pdf.section_title("Suspicious Domains", "Domains that may be used for malicious purposes")
        pdf.item_list(static_results["suspicious_domains"]["domains_detected"], color=(170, 120, 70))
    
    # IP addresses
    if static_results["ip_addresses"]["found"]:
        pdf.section_title("IP Addresses", "IP addresses found in the file")
        pdf.item_list(static_results["ip_addresses"]["ip_addresses"], color=(25, 25, 120))
    
    # PowerShell commands
    if static_results["powershell_commands"]["found"]:
        pdf.section_title("PowerShell Commands", "Potentially malicious PowerShell commands")
        pdf.item_list([cmd[:100] + "..." if len(cmd) > 100 else cmd for cmd in static_results["powershell_commands"]["powershell_commands"]], color=(100, 80, 200))
    
    # Registry paths
    if static_results["registry_paths"]["found"]:
        pdf.section_title("Registry Paths", "Registry paths that may be modified")
        pdf.item_list(static_results["registry_paths"]["registry_paths"], color=(90, 140, 120))
    
    # YARA patterns
    if static_results["yara_patterns"]["found"]:
        pdf.section_title("YARA-like Rules", "YARA rule patterns detected")
        pdf.item_list([rule[:100] + "..." if len(rule) > 100 else rule for rule in static_results["yara_patterns"]["yara_patterns"]], color=(100, 110, 190))
    
    # Base64 strings
    if static_results["base64_strings"]["found"]:
        pdf.section_title("Base64 Encoded Strings", "Potentially obfuscated content")
        for b64_string, decoded_content in static_results["base64_strings"]["base64_strings"][:10]:
            # Convert binary data to safe ASCII representation
            preview = str(decoded_content[:32]).replace("\u2022", "*").replace("•", "*")
            # Ensure all characters are ASCII
            safe_preview = preview.encode("ascii", "replace").decode("ascii")
            safe_base64 = b64_string[:30].encode("ascii", "replace").decode("ascii")
            pdf.item_list([f"{safe_base64}... -> {safe_preview}"], color=(80, 100, 150))
    
    # High entropy sections
    if static_results["high_entropy_sections"]:
        pdf.section_title("High Entropy Sections", "Potentially packed or encrypted content")
        for offset, entropy in static_results["high_entropy_sections"][:10]:
            pdf.item_list([f"Offset {hex(offset)} - Entropy: {entropy:.2f}"], color=(110, 70, 170))
    
    # EICAR detection
    if static_results["eicar_detected"]["found"]:
        pdf.section_title("EICAR Test Signature", "Test signature for antivirus validation")
        pdf.item_list([static_results["eicar_detected"]["signature_info"]], color=(200, 30, 30))
    
    # === STRING ANALYSIS ===
    if ascii_strings:
        pdf.section_title("String Analysis", f"First 100 of {len(ascii_strings)} extracted strings")
        # Use enhanced multi-column display
        pdf.ascii_strings_table(ascii_strings, columns=3, max_strings=100)


def _generate_virustotal_section(pdf: MalwareAnalysisReport, vt_results: Dict, exe_file_path: Path):

    # === MITRE ATT&CK MAPPING ===
    pdf.section_title("MITRE ATT&CK Mapping", "Detected adversary techniques and tactics")
    vt_attrs = vt_results.get("data", {}).get("attributes", {}) if vt_results and isinstance(vt_results, dict) else {}
    # Extract MITRE ATT&CK techniques using analyzer logic
    mitre_list = VirusTotalAnalyzer.extract_mitre_attack(vt_attrs)
    pdf.mitre_attack_table(mitre_list)
    # Debug: Print available VirusTotal attributes
    print(f"[DEBUG] Available VirusTotal attributes: {list(vt_attrs.keys())}")

    # === VIRUSTOTAL SUMMARY (MERGED) ===
    summary_dict = VirusTotalAnalyzer.extract_summary_attributes(vt_attrs)
    # Add extra file metadata fields not in summary_dict, avoiding duplicates
    def add_if_not_present(d, key, value):
        if key not in d and value is not None:
            d[key] = value

    # Prepare merged summary
    merged_summary = dict(summary_dict) if summary_dict else {}
    # Add extra fields from file metadata if not already present
    if vt_attrs.get("magic"):
        add_if_not_present(merged_summary, "Magic", vt_attrs.get("magic"))
    if vt_attrs.get("times_submitted"):
        add_if_not_present(merged_summary, "Times Submitted", str(vt_attrs.get("times_submitted", 0)))
    if vt_attrs.get("reputation"):
        add_if_not_present(merged_summary, "Reputation Score", str(vt_attrs.get("reputation", 0)))
    if vt_attrs.get("file_type"):
        add_if_not_present(merged_summary, "File Type (VT)", vt_attrs.get("file_type"))
    if vt_attrs.get("type_extension"):
        add_if_not_present(merged_summary, "Extension", vt_attrs.get("type_extension"))
    # Format file size if present and not already formatted
    if "File Size" in merged_summary and isinstance(merged_summary["File Size"], int):
        merged_summary["File Size"] = f"{merged_summary['File Size']:,} bytes"
    elif vt_attrs.get("size") and "File Size" not in merged_summary:
        merged_summary["File Size"] = f"{vt_attrs.get('size', 0):,} bytes"
    # Format first/last submission dates if present and not already formatted
    from datetime import datetime
    if "First Submission" in merged_summary:
        val = merged_summary["First Submission"]
        if isinstance(val, (int, float)):
            merged_summary["First Submission"] = datetime.fromtimestamp(val).isoformat()
    elif vt_attrs.get("first_submission_date"):
        val = vt_attrs.get("first_submission_date")
        merged_summary["First Submission"] = datetime.fromtimestamp(val).isoformat() if isinstance(val, (int, float)) else str(val)
    if "Last Submission" in merged_summary:
        val = merged_summary["Last Submission"]
        if isinstance(val, (int, float)):
            merged_summary["Last Submission"] = datetime.fromtimestamp(val).isoformat()
    elif vt_attrs.get("last_submission_date"):
        val = vt_attrs.get("last_submission_date")
        merged_summary["Last Submission"] = datetime.fromtimestamp(val).isoformat() if isinstance(val, (int, float)) else str(val)

    pdf.section_title("VirusTotal Summary", "Key VirusTotal v3 attributes and file metadata")
    pdf.virustotal_summary_table(merged_summary)
    
    # === THREAT CLASSIFICATION ===
    pdf.section_title("Threat Classification", "Threat intelligence from VirusTotal")
    threat_info = {}
    if vt_attrs.get("popular_threat_classification"):
        threat_class = vt_attrs.get("popular_threat_classification", {})
        if threat_class.get("suggested_threat_label"):
            threat_info["Threat Family"] = threat_class.get("suggested_threat_label", "N/A")
        if threat_class.get("popular_threat_category"):
            threat_info["Threat Category"] = str(threat_class.get("popular_threat_category", "N/A"))
    
    if vt_attrs.get("type_tags"):
        threat_info["Type Tags"] = ", ".join(vt_attrs.get("type_tags", []))
    
    # Always show this section, even if empty
    if not threat_info:
        threat_info["Status"] = "No threat classification available"
    pdf.value_table(threat_info)
    
    # === THREAT NAMES ===
    pdf.section_title("Threat Names", "Threat names identified by various engines")
    if vt_attrs.get("threat_names"):
        threat_names = vt_attrs.get("threat_names", [])
        if threat_names:
            pdf.item_list(threat_names[:20], color=(200, 50, 50))  # Limit to first 20
            if len(threat_names) > 20:
                pdf.highlight_text(f"...{len(threat_names)-20} more threat names omitted for brevity.")
        else:
            pdf.highlight_text("No threat names available")
    else:
        pdf.highlight_text("No threat names available")
    
    # === DETECTION STATISTICS ===
    vt_stats = vt_attrs.get("last_analysis_stats", {})
    if vt_stats:
        pdf.section_title("Detection Statistics", "Summary of antivirus engine results")
        total_scans = sum(vt_stats.values())
        malicious = vt_stats.get("malicious", 0)
        suspicious = vt_stats.get("suspicious", 0)
        undetected = vt_stats.get("undetected", 0)
        
        stats_info = {
            "Total Engines": str(total_scans),
            "Malicious Detections": str(malicious),
            "Suspicious Detections": str(suspicious),
            "Clean Results": str(undetected),
            "Detection Ratio": f"{malicious + suspicious}/{total_scans}",
            "Last Analysis": datetime.fromtimestamp(vt_attrs.get("last_analysis_date", 0)).isoformat() if vt_attrs.get("last_analysis_date") and isinstance(vt_attrs.get("last_analysis_date"), (int, float)) else vt_attrs.get("last_analysis_date").isoformat() if isinstance(vt_attrs.get("last_analysis_date"), datetime) else "N/A"
        }
        pdf.value_table(stats_info)
    
    # === COMMUNITY INTELLIGENCE ===
    pdf.section_title("Community Intelligence", "Community votes and comments")
    community_info = {}
    if vt_attrs.get("votes"):
        votes = vt_attrs.get("votes", {})
        community_info["Harmless Votes"] = str(votes.get("harmless", 0))
        community_info["Malicious Votes"] = str(votes.get("malicious", 0))
    if vt_attrs.get("comment_count"):
        community_info["Comments"] = str(vt_attrs.get("comment_count", 0))
    
    # Always show this section
    if not community_info:
        community_info["Status"] = "No community data available"
    pdf.value_table(community_info)
    
    # === YARA RESULTS ===
    pdf.section_title("YARA Rule Matches", "Community YARA rules that matched this file")
    if vt_attrs.get("crowdsourced_yara_results"):
        yara_results = vt_attrs.get("crowdsourced_yara_results", [])
        if yara_results:
            yara_matches = []
            for yara_match in yara_results[:10]:  # Limit to first 10
                rule_name = yara_match.get("rule_name", "Unknown")
                source = yara_match.get("source", "Unknown")
                yara_matches.append(f"{rule_name} (by {source})")
            pdf.item_list(yara_matches, color=(100, 100, 200))
            if len(yara_results) > 10:
                pdf.highlight_text(f"...{len(yara_results)-10} more YARA matches omitted for brevity.")
        else:
            pdf.highlight_text("No YARA rule matches found")
    else:
        pdf.highlight_text("No YARA rule matches found")
    
    # === SANDBOX ANALYSIS ===
    pdf.section_title("Sandbox Analysis", "Behavioral analysis results")
    if vt_attrs.get("sandbox_verdicts"):
        sandbox_verdicts = vt_attrs.get("sandbox_verdicts", {})
        if sandbox_verdicts:
            sandbox_info = {}
            for sandbox_name, verdict_data in sandbox_verdicts.items():
                if isinstance(verdict_data, dict) and verdict_data.get("category"):
                    sandbox_info[sandbox_name] = verdict_data.get("category", "Unknown")
                elif isinstance(verdict_data, str):
                    sandbox_info[sandbox_name] = verdict_data
            if sandbox_info:
                pdf.value_table(sandbox_info)
            else:
                pdf.highlight_text("No sandbox analysis results available")
        else:
            pdf.highlight_text("No sandbox analysis results available")
    else:
        pdf.highlight_text("No sandbox analysis results available")
    
    # === BEHAVIORAL INDICATORS ===
    pdf.section_title("Behavioral Summary", "Behavioral analysis indicators")
    if vt_attrs.get("behaviour_summary"):
        behavior = vt_attrs.get("behaviour_summary", {})
        if behavior:
            behavior_info = {}
            if behavior.get("files_written"):
                behavior_info["Files Written"] = str(len(behavior.get("files_written", [])))
            if behavior.get("files_deleted"):
                behavior_info["Files Deleted"] = str(len(behavior.get("files_deleted", [])))
            if behavior.get("registry_keys_set"):
                behavior_info["Registry Keys Set"] = str(len(behavior.get("registry_keys_set", [])))
            if behavior.get("processes_created"):
                behavior_info["Processes Created"] = str(len(behavior.get("processes_created", [])))
            if behavior.get("network_connections"):
                behavior_info["Network Connections"] = str(len(behavior.get("network_connections", [])))
            
            if behavior_info:
                pdf.value_table(behavior_info)
            else:
                pdf.highlight_text("No behavioral indicators available")
        else:
            pdf.highlight_text("No behavioral indicators available")
    else:
        pdf.highlight_text("No behavioral indicators available")
    
    # === NETWORK ACTIVITY ===
    pdf.section_title("Network Activity", "Network connections observed during analysis")
    network_info = []
    if vt_attrs.get("contacted_domains"):
        domains = vt_attrs.get("contacted_domains", [])
        if domains:
            network_info.extend([f"Domain: {domain}" for domain in domains[:10]])
    
    if vt_attrs.get("contacted_ips"):
        ips = vt_attrs.get("contacted_ips", [])
        if ips:
            network_info.extend([f"IP: {ip}" for ip in ips[:10]])
    
    if vt_attrs.get("contacted_urls"):
        urls = vt_attrs.get("contacted_urls", [])
        if urls:
            network_info.extend([f"URL: {url}" for url in urls[:5]])
    
    if network_info:
        pdf.item_list(network_info, color=(50, 100, 150))
    else:
        pdf.highlight_text("No network activity recorded")
    
    # === PACKERS/PROTECTORS ===
    pdf.section_title("Packers/Protectors", "Detected packers and protectors")
    if vt_attrs.get("packers"):
        packers = vt_attrs.get("packers", {})
        if packers:
            packer_list = []
            for packer_name, packer_info in packers.items():
                if isinstance(packer_info, str):
                    packer_list.append(f"{packer_name}: {packer_info}")
                else:
                    packer_list.append(packer_name)
            pdf.item_list(packer_list, color=(150, 100, 50))
        else:
            pdf.highlight_text("No packers or protectors detected")
    else:
        pdf.highlight_text("No packers or protectors detected")
    
    # === PE INFORMATION ===
    pdf.section_title("VirusTotal PE Analysis", "PE header information from VirusTotal")
    if vt_attrs.get("pe_info"):
        pe_vt_info = vt_attrs.get("pe_info", {})
        if pe_vt_info:
            pe_display_info = {}
            if pe_vt_info.get("timestamp"):
                pe_timestamp = pe_vt_info.get("timestamp")
                if isinstance(pe_timestamp, datetime):
                    pe_display_info["PE Timestamp"] = pe_timestamp.isoformat()
                else:
                    pe_display_info["PE Timestamp"] = datetime.fromtimestamp(pe_timestamp).isoformat()
            if pe_vt_info.get("machine_type"):
                pe_display_info["Machine Type"] = str(pe_vt_info.get("machine_type"))
            if pe_vt_info.get("subsystem"):
                pe_display_info["Subsystem"] = str(pe_vt_info.get("subsystem"))
            if pe_vt_info.get("entry_point"):
                pe_display_info["Entry Point"] = hex(pe_vt_info.get("entry_point"))
            
            if pe_display_info:
                pdf.value_table(pe_display_info)
            else:
                pdf.highlight_text("No PE information available")
        else:
            pdf.highlight_text("No PE information available")
    else:
        pdf.highlight_text("No PE information available")
    
    # === IMPORTS/EXPORTS ===
    pdf.section_title("Imported Functions", "Functions imported by the executable")
    if vt_attrs.get("imports"):
        imports = vt_attrs.get("imports", [])
        if imports:
            import_list = []
            for imp in imports[:20]:  # Limit to first 20
                if isinstance(imp, dict):
                    lib_name = imp.get("library_name", "Unknown")
                    func_name = imp.get("function_name", "Unknown")
                    import_list.append(f"{lib_name}::{func_name}")
                else:
                    import_list.append(str(imp))
            pdf.item_list(import_list, color=(80, 80, 80))
            if len(imports) > 20:
                pdf.highlight_text(f"...{len(imports)-20} more imports omitted for brevity.")
        else:
            pdf.highlight_text("No import information available")
    else:
        pdf.highlight_text("No import information available")
    
    # === ADDITIONAL VIRUSTOTAL SECTIONS ===
    
    # File type and classification
    pdf.section_title("File Classification", "File type and format information")
    file_class_info = {}
    if vt_attrs.get("type_description"):
        file_class_info["File Type"] = vt_attrs.get("type_description", "Unknown")
    if vt_attrs.get("type_extension"):
        file_class_info["Extension"] = vt_attrs.get("type_extension", "Unknown")
    if vt_attrs.get("magic"):
        file_class_info["Magic Bytes"] = vt_attrs.get("magic", "Unknown")
    if vt_attrs.get("ssdeep"):
        file_class_info["SSDeep Hash"] = vt_attrs.get("ssdeep", "N/A")[:50] + "..." if len(vt_attrs.get("ssdeep", "")) > 50 else vt_attrs.get("ssdeep", "N/A")
    
    if not file_class_info:
        file_class_info["Status"] = "No file classification available"
    pdf.value_table(file_class_info)
    
    # Signature information
    pdf.section_title("Digital Signatures", "Code signing and certificate information")
    if vt_attrs.get("signature_info"):
        sig_info = vt_attrs.get("signature_info", {})
        if sig_info and isinstance(sig_info, dict):
            sig_display = {}
            for key, value in sig_info.items():
                sig_display[key.replace("_", " ").title()] = str(value)[:100]
            pdf.value_table(sig_display)
        else:
            pdf.highlight_text("No signature information available")
    else:
        pdf.highlight_text("No signature information available")
    
    # Detection results table (existing)
    scan_results = vt_attrs.get("last_analysis_results", {})
    if scan_results:
        pdf.section_title("Antivirus Detection Details", "Individual engine detection results")
        pdf.detection_table(scan_results)

# === Main Functions ===

def parse_arguments() -> argparse.Namespace:
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="Comprehensive Malware Analysis Report Generator",
        epilog="This tool combines static analysis and VirusTotal integration for comprehensive malware analysis."
    )
    
    parser.add_argument(
        "file_base",
        type=str,
        help="Base filename of the malware (without extension, e.g. 'malware')"
    )
    
    parser.add_argument(
        "--api-key",
        type=str,
        help="VirusTotal API key (or set VT_API_KEY environment variable)"
    )
    
    parser.add_argument(
        "--output",
        type=Path,
        help="Output PDF report path (default: bin/reports/<base_filename>_comprehensive_report.pdf)"
    )
    
    parser.add_argument(
        "--skip-vt",
        action="store_true",
        help="Skip VirusTotal analysis (static analysis only)"
    )
    
    return parser.parse_args()

async def main_async() -> int:
    """Main async entry point."""
    print("=== Comprehensive Malware Analysis Report Generator ===")
    print("Static Analysis + VirusTotal Integration")
    print("Juan Herbst - Master Cyber Security and Digital Forensics\n")
    
    # Parse arguments
    args = parse_arguments()
    
    # Construct file paths from base filename
    base_name = args.file_base
    pyc_file_path = Path("bin") / f"{base_name}.pyc"
    exe_file_path = Path("bin") / f"{base_name}.exe"
    # Validate files exist
    if not pyc_file_path.exists():
        print(f" Python compiled file not found: {pyc_file_path}")
        return 1
    
    if not pyc_file_path.is_file():
        print(f" Not a file: {pyc_file_path}")
        return 1
    
    # Check if exe exists for VirusTotal analysis
    exe_exists = exe_file_path.exists() and exe_file_path.is_file()
    if not exe_exists:
        print(f"Executable file not found: {exe_file_path}")
        print(f" Will proceed with static analysis only on {pyc_file_path}")
    
    # Get API key
    api_key = args.api_key or os.getenv("VT_API_KEY")
    if not args.skip_vt and not api_key:
        print("No VirusTotal API key provided. Continuing with static analysis only.")
        print("   Use --api-key or set VT_API_KEY environment variable for VirusTotal integration.")
        print("   Use --skip-vt to suppress this warning.\n")
    
    # Set output path - save reports in bin/reports/ folder
    reports_dir = Path("bin/reports").resolve()
    reports_dir.mkdir(parents=True, exist_ok=True)  # Create reports directory if it doesn't exist
    
    if args.output:
        # If user specifies custom output, save it in reports folder
        if args.output.is_absolute():
            output_path = args.output
        else:
            output_path = reports_dir / args.output.name
    else:
        output_path = reports_dir / f"{base_name}_comprehensive_report.pdf"
    
    try:
        # Generate comprehensive report
        success = await generate_comprehensive_report(
            pyc_file_path, exe_file_path, output_path, api_key, args.skip_vt, exe_exists
        )
        
        if success:
            print(f"\nAnalysis complete! Comprehensive report saved to: {output_path}")
            return 0
        else:
            print(f"\n Failed to generate report")
            return 1
            
    except KeyboardInterrupt:
        print("\n Analysis interrupted by user")
        return 1
    except Exception as error:
        print(f"\n Unexpected error: {error}")
        return 1
        return 1

def main() -> int:
    """Main entry point that runs the async function."""
    return asyncio.run(main_async())

if __name__ == "__main__":
    sys.exit(main())
