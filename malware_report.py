"""
static_reporter_pdf.py
----------------------
Academic reporting tool: Extracts static malware indicators from a Windows EXE/DLL file.
Outputs a visually professional PDF report.
"""

import sys
import datetime
import hashlib
import re
import base64
import pefile
from malware_pdf_report import malware_pdf_report
from pathlib import Path
from math import log2

# === Analysis Patterns and Thresholds ===

SUSPICIOUS_KEYWORDS = [
    "ransomware",
    "keylogger",
    "backdoor",
    "shellcode",
    "exploit",
    "virus",
    "trojan",
    "worm",
    "malware",
    "spyware",
    "adware",
    "phishing",
    "botnet",
    "exploit kit",
    "rootkit",
    "DDoS attack",
    "SQL injection",
    "XSS attack",
    "command injection",
    "buffer overflow",
]

SUSPICIOUS_DOMAINS = [
    r"fake\.hacker\.com",
    r"haxor\-c2\.example\.net",
    r"evil\.malicious\.com",
    r"malicious\.anonymous\.com",
    r"c2\..*\.com",
    r"evil\.[a-zA-Z0-9\-]+\.(com|net|org)",
    r"malicious\.[a-zA-Z0-9\-]+\.(com|net|org)",
    r"hacker\.[a-zA-Z0-9\-]+\.(com|net|org)",
    r"backdoor\.[a-zA-Z0-9\-]+\.(com|net|org)",
    r"trojan\.[a-zA-Z0-9\-]+\.(com|net|org)",
    r"botnet\.[a-zA-Z0-9\-]+\.(com|net|org)"
]

SUSPICIOUS_FILENAMES = [
    "wannacry.exe",
    "evil.dll",
    "payload.bin",
    "exploit.sys",
    "iloveyou",
    "stuxnet",
    "zues"
]

IP_REGEX = r"(?:[0-9]{1,3}\.){3}[0-9]{1,3}"

POWERSHELL_REGEX = r"powershell.+?(?:\-enc|\-encodedcommand)"

REGISTRY_PATH_REGEX = r"Software\\Microsoft\\Windows\\CurrentVersion\\Run"

YARA_RULE_REGEX = r"rule\s+\w+\s*\{[^}]+\}"

EICAR_SIGNATURE = (
    b"X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"
)

HIGH_ENTROPY_THRESHOLD = 4.5


# === Utility Functions ===
def extract_ascii_strings_from_binary(binary_data, min_length=6):
    """
    Extracts ASCII strings from binary data.
    This function scans the given binary data and extracts all contiguous sequences of printable ASCII characters
    (with character codes in the range 0x20 to 0x7E) that are at least `min_length` characters long.
    arguments:
        The binary data to search for ASCII strings.
        The minimum length of ASCII strings to extract. Defaults to 6.
    returns:
        A list of extracted ASCII strings.
    """
    # rb = raw binary string
    # 0x20 to 0x7E which are the standard printable ASCII characters
    pattern = rb"[\x20-\x7E]{%d,}" % min_length
    ascii_strings = re.findall(pattern, binary_data)
    decoded_strings = [s.decode("ascii", errors="ignore") for s in ascii_strings]
    return decoded_strings
    #return [match.decode("ascii") for match in re.findall(pattern, binary_data)]


def detect_base64_encoded_strings(string_list, min_length=16):
    """
    Detects and decodes Base64-encoded strings from a list of string candidates.
    arguments:
        List of strings to check for Base64 encoding.
        Minimum length a string must have to be considered as a Base64 candidate. Defaults to 16.
    returns:
        Each tuple contains the original Base64 string and the first 32 bytes of its decoded content.
    """
    decoded_results = []
    for string_candidate in string_list:
        if len(string_candidate) >= min_length and re.fullmatch(
            r"[A-Za-z0-9+/=]+", string_candidate
        ):
            try:
                decoded_bytes = base64.b64decode(
                    string_candidate, validate=True)
                decoded_results.append((string_candidate, decoded_bytes[:32]))
            except Exception:
                continue
    return decoded_results


def calculate_shannon_entropy(byte_sequence):
    """
    Calculates the Shannon entropy of a given byte sequence.
    Shannon entropy is a measure of the randomness or unpredictability in a data set.
    A higher entropy value indicates more randomness.
    arguments:
        byte_sequence (bytes or str): The input data to analyze. If a string is provided, it will be encoded to bytes.
    returns:
        float: The Shannon entropy value of the input sequence. returns 0.0 for empty input.
        note: - by using packing / compression of executable files.
        - For example, when using a tool like UPX (Ultimate Packer for eXecutables) to compress a malware executable,
        the entropy of the original file is often lower due to the repetitive patterns in the code.
        - After compression with UPX (e.g., `upx.exe --best --force malware.exe`), the entropy significantly increases.
    """
    if isinstance(byte_sequence, str):
        byte_sequence = byte_sequence.encode()
    if not byte_sequence:
        return 0.0
    frequency_table = [0] * 256
    for byte in byte_sequence:
        frequency_table[byte] += 1
    entropy = 0.0
    for byte_count in frequency_table:
        if byte_count:
            probability = byte_count / len(byte_sequence)
            entropy -= probability * log2(probability)
    return entropy


def detect_high_entropy_sections(
    binary_data, window_size=256, entropy_threshold=HIGH_ENTROPY_THRESHOLD
):
    """
    Scans binary data for sections with high Shannon entropy, which may indicate obfuscated or encrypted content.
    arguments:
        The binary data to analyze.
        The size of the sliding window (in bytes) used to calculate entropy. Defaults to 256.
        The minimum entropy value to consider a section as suspicious. Defaults to HIGH_ENTROPY_THRESHOLD.
    returns:
        A list of tuples, each containing the offset (int) of the suspicious chunk and its calculated entropy (float).
    """
    suspicious_chunks = []
    for offset in range(0, len(binary_data) - window_size, window_size):
        chunk = binary_data[offset: offset + window_size]
        entropy = calculate_shannon_entropy(chunk)
        if entropy >= entropy_threshold:
            suspicious_chunks.append((offset, entropy))
    return suspicious_chunks


def detect_pe_headers(file_path):
    """
    Analyzes a Portable Executable (PE) file and extracts key header information.
    arguments:
        The path to the PE file to analyze.
    returns:
        A dictionary containing:
            - "entry_point" (str): The entry point address of the executable in hexadecimal.
            - "image_base" (str): The preferred image base address in hexadecimal.
            - "sections" (list of tuples): A list of tuples for each section, where each tuple contains:
                - section name (str)
                - virtual address (str, hexadecimal)
                - virtual size (str, hexadecimal)
    """
    # Create a copy of the file path to avoid modifying the original
    pe_file_path = file_path
    
    # If file is .pyc, replace with .exe and look in bin folder
    if file_path.endswith('.pyc'):
        filename = Path(file_path).stem + '.exe'
        pe_file_path = f'./bin/{filename}'
        print(f"Converting .pyc to .exe: {pe_file_path}")
    
    try:
        pe = pefile.PE(pe_file_path)
        return {
            "entry_point": hex(getattr(pe.OPTIONAL_HEADER, "AddressOfEntryPoint", 0)),
            "image_base": hex(getattr(pe.OPTIONAL_HEADER, "ImageBase", 0)),
            "sections": [
                (
                    section.Name.decode(errors="ignore").strip("\x00"),
                    hex(section.VirtualAddress),
                    hex(section.Misc_VirtualSize),
                )
                for section in pe.sections
            ],
        }
    except pefile.PEFormatError:
        return {
            "entry_point": "N/A (Not a valid PE file)",
            "image_base": "N/A (Not a valid PE file)",
            "sections": [("N/A", "N/A", "N/A")],
        }


def detect_file_information(file_path):
    """
    Extracts and returns detailed information about a file, including its name, size, cryptographic hashes (SHA256, MD5, SHA1),
    and timestamps for creation and modification.
    arguments:
        The path to the file whose information is to be detected.
    returns:
        dict: A dictionary containing the following keys:
            - "File Name": The name of the file.
            - "File Size": The size of the file in bytes (formatted with commas).
            - "SHA256": The SHA256 hash of the file's contents.
            - "MD5": The MD5 hash of the file's contents.
            - "SHA1": The SHA1 hash of the file's contents.
            - "Created": (optional) The ISO-formatted creation timestamp of the file.
            - "Modified": (optional) The ISO-formatted last modification timestamp of the file.
    """
    file_object = Path(file_path)
    file_bytes = file_object.read_bytes()
    info = {
        "File Name": str(file_object.name),
        "File Size": f"{file_object.stat().st_size:,} bytes",
        "SHA256": hashlib.sha256(file_bytes).hexdigest(),
        "MD5": hashlib.md5(file_bytes).hexdigest(),
        "SHA1": hashlib.sha1(file_bytes).hexdigest(),
    }
    try:
        info["Created"] = datetime.datetime.fromtimestamp(
            file_object.stat().st_ctime
        ).isoformat()
        info["Modified"] = datetime.datetime.fromtimestamp(
            file_object.stat().st_mtime
        ).isoformat()
    except OSError:
        pass
    return info


def detect_suspicious_file_names(file_path, ascii_strings):
    """
    Detects suspicious file names by analyzing both the file path and embedded strings in the file content.
    This function checks for known suspicious file names in two ways:
    1. Direct filename matching against the actual file name
    2. Searching for suspicious filename references embedded within the file's ASCII strings

    arguments:
        file_path (str): The path to the file being analyzed
        ascii_strings (list): A list of ASCII strings extracted from the file content

    returns:
        dict: A dictionary containing detection results with the following keys:
            - "found" (bool): True if any suspicious filenames were detected
            - "filename_matches" (list): List of suspicious patterns found in the actual filename
            - "embedded_matches" (list): List of suspicious filenames found in file content
    """
    file_object = Path(file_path)
    filename_matches = []
    embedded_matches = []

    for suspicious_name in SUSPICIOUS_FILENAMES:
        # Check if suspicious name is in the actual filename
        if suspicious_name.lower() in file_object.name.lower():
            filename_matches.append(suspicious_name)

        # Check if suspicious name is embedded in the file content
        elif any(suspicious_name.lower() in string.lower() for string in ascii_strings):
            embedded_matches.append(suspicious_name)

    return {
        "found": bool(filename_matches or embedded_matches),
        "filename_matches": filename_matches,
        "embedded_matches": embedded_matches
    }


def detect_suspicious_keywords(ascii_strings):
    """
    Detects suspicious keywords within a list of ASCII strings extracted from a file.
    This function searches through the provided ASCII strings for matches against
    a predefined list of suspicious keywords commonly associated with malware.

    arguments:
        ascii_strings (list): A list of ASCII strings extracted from file content

    returns:
        dict: A dictionary containing detection results with the following keys:
            - "found" (bool): True if any suspicious keywords were detected
            - "keywords_detected" (list): List of suspicious keywords found in the content
            - "total_matches" (int): Total number of keyword matches found
    """
    # Use only the ASCII strings extracted from the binary being analyzed
    combined_strings = ascii_strings
    
    keywords_detected = []
    total_matches = 0

    for keyword in SUSPICIOUS_KEYWORDS:
        matches = [string for string in combined_strings if keyword.lower()
                   in string.lower()]
        if matches:
            keywords_detected.append(keyword)
            total_matches += len(matches)

    return {
        "found": bool(keywords_detected),
        "keywords_detected": keywords_detected,
        "total_matches": total_matches
    }


def detect_suspicious_domains(ascii_strings):
    """
    Detects suspicious domains within a list of ASCII strings extracted from a file.
    This function performs comprehensive domain detection using multiple methods:
    1. Direct regex pattern matching against known suspicious domains
    2. URL extraction and analysis (http/https URLs)
    3. Domain-only extraction from various contexts

    arguments:
        ascii_strings (list): A list of ASCII strings extracted from file content

    returns:
        dict: A dictionary containing detection results with the following keys:
            - "found" (bool): True if any suspicious domains were detected
            - "domains_detected" (list): List of suspicious domains found with detection method
            - "total_matches" (int): Total number of domain matches found
    """
    
    # Use only the ASCII strings extracted from the binary being analyzed
    all_strings = ascii_strings
    
    found_domains = set()  # Use set to avoid duplicates
    total_matches = 0

    # Join all strings for comprehensive search
    all_text = " ".join(all_strings)

    # Method 1: Direct pattern matching in individual strings
    for domain_pattern in SUSPICIOUS_DOMAINS:
        for string in all_strings:
            matches = re.findall(domain_pattern, string, re.IGNORECASE)
            for match in matches:
                found_domains.add(
                    f"{string[:50]}")
                total_matches += 1

    # Method 2: Extract URLs (http/https) and check domains
    url_pattern = r'https?://(?:www\.)?([a-zA-Z0-9\-\.]+\.[a-zA-Z]{2,})'
    urls = re.findall(url_pattern, all_text, re.IGNORECASE)
    for url_domain in urls:
        # Check if extracted domain matches any suspicious pattern
        for domain_pattern in SUSPICIOUS_DOMAINS:
            if re.search(domain_pattern, url_domain, re.IGNORECASE):
                found_domains.add(f"{url_domain}")
                total_matches += 1
                break
        # Also check for suspicious keywords in domain names
        suspicious_keywords = ['evil', 'malicious', 'fake',
                               'hacker', 'c2', 'backdoor', 'trojan', 'botnet']
        if any(keyword in url_domain.lower() for keyword in suspicious_keywords):
            found_domains.add(f"{url_domain}")
            total_matches += 1

    # Method 3: General domain extraction (without protocol)
    domain_pattern = r'\b([a-zA-Z0-9\-]+\.(?:com|net|org|info|biz|co|io|me|tk|ml|ga|cf))\b'
    domains = re.findall(domain_pattern, all_text, re.IGNORECASE)
    for domain in domains:
        # Check against suspicious patterns
        for suspicious_pattern in SUSPICIOUS_DOMAINS:
            if re.search(suspicious_pattern, domain, re.IGNORECASE):
                found_domains.add(f"Domain: {domain}")
                total_matches += 1
                break
        # Check for suspicious keywords in domain
        suspicious_keywords = ['evil', 'malicious', 'fake',
                               'hacker', 'c2', 'backdoor', 'trojan', 'botnet']
        if any(keyword in domain.lower() for keyword in suspicious_keywords):
            found_domains.add(f"Suspicious domain: {domain}")
            total_matches += 1

    return {
        "found": bool(found_domains),
        "domains_detected": sorted(list(found_domains)),
        "total_matches": total_matches
    }


def detect_ip_addresses(ascii_strings):
    """
    Detects IP addresses within a list of ASCII strings extracted from a file.
    This function searches through the provided ASCII strings for patterns matching
    IPv4 addresses using regex pattern matching.

    arguments:
        ascii_strings (list): A list of ASCII strings extracted from file content

    returns:
        dict: A dictionary containing detection results with the following keys:
            - "found" (bool): True if any IP addresses were detected
            - "ip_addresses" (list): List of unique IP addresses found in the content
            - "total_matches" (int): Total number of IP address matches found
    """
    all_strings_joined = " ".join(ascii_strings)
    ip_addresses_set = set(re.findall(IP_REGEX, all_strings_joined))
    # Sort for consistent output
    ip_addresses_list = sorted(list(ip_addresses_set))

    return {
        "found": bool(ip_addresses_list),
        "ip_addresses": ip_addresses_list,
        "total_matches": len(ip_addresses_list)
    }


def detect_powershell_commands(ascii_strings):
    """
    Detects PowerShell commands within a list of ASCII strings extracted from a file.
    This function searches through the provided ASCII strings for patterns matching
    PowerShell commands using regex pattern matching with case-insensitive search.

    arguments:
        ascii_strings (list): A list of ASCII strings extracted from file content

    returns:
        dict: A dictionary containing detection results with the following keys:
            - "found" (bool): True if any PowerShell commands were detected
            - "powershell_commands" (list): List of PowerShell commands found in the content
            - "total_matches" (int): Total number of PowerShell command matches found
    """
    powershell_commands = [
        string
        for string in ascii_strings
        if re.search(POWERSHELL_REGEX, string, re.IGNORECASE)
    ]

    return {
        "found": bool(powershell_commands),
        "powershell_commands": powershell_commands,
        "total_matches": len(powershell_commands)
    }


def detect_registry_paths(ascii_strings):
    """
    Detects suspicious registry paths within a list of ASCII strings extracted from a file.
    This function searches through the provided ASCII strings for patterns matching
    Windows registry paths using regex pattern matching.

    arguments:
        ascii_strings (list): A list of ASCII strings extracted from file content

    returns:
        dict: A dictionary containing detection results with the following keys:
            - "found" (bool): True if any registry paths were detected
            - "registry_paths" (list): List of registry paths found in the content
            - "total_matches" (int): Total number of registry path matches found
    """
    registry_paths = [
        string for string in ascii_strings if re.search(REGISTRY_PATH_REGEX, string)
    ]

    return {
        "found": bool(registry_paths),
        "registry_paths": registry_paths,
        "total_matches": len(registry_paths)
    }


def detect_yara_patterns(ascii_strings):
    """
    Detects YARA-like rules within a list of ASCII strings extracted from a file.
    This function searches through the provided ASCII strings for patterns matching
    YARA rule syntax using regex pattern matching.

    arguments:
        ascii_strings (list): A list of ASCII strings extracted from file content

    returns:
        dict: A dictionary containing detection results with the following keys:
            - "found" (bool): True if any YARA patterns were detected
            - "yara_patterns" (list): List of YARA patterns found in the content
            - "total_matches" (int): Total number of YARA pattern matches found
    """
    yara_patterns = [
        string for string in ascii_strings if re.search(YARA_RULE_REGEX, string)
    ]

    return {
        "found": bool(yara_patterns),
        "yara_patterns": yara_patterns,
        "total_matches": len(yara_patterns)
    }


def detect_eicar_signature(binary_data):
    """
    Detects the EICAR test signature within binary data.
    This function searches the provided binary data for the presence of the
    EICAR anti-virus test signature.

    arguments:
        binary_data (bytes): The binary data to be scanned for the EICAR signature

    returns:
        dict: A dictionary containing detection results with the following keys:
            - "found" (bool): True if the EICAR signature was detected
            - "signature_detected" (bool): Same as found, for consistency
            - "signature_info" (str): Information about the detected signature
    """
    signature_found = EICAR_SIGNATURE in binary_data

    return {
        "found": signature_found,
        "signature_detected": signature_found,
        "signature_info": "EICAR test signature detected!" if signature_found else "No EICAR test signature detected"
    }


# === Reporting Section Functions ===
def write_file_information(pdf, file_path):
    """
    Writes file information to a PDF report.
    This function adds a "File Information" section to the provided PDF object,
    extracts information about the specified file using the detect_file_information
    function, and adds this information as a value table to the PDF.
    arguments:
        An object representing the PDF report, expected to have 'section_title' and 'value_table' methods.
        The path to the file whose information is to be extracted and written to the PDF.
    """
    pdf.section_title("File Information")
    fileinfo = detect_file_information(file_path)
    pdf.value_table(fileinfo)


def write_pe_header(pdf, file_path):
    """
    Writes the PE (Portable Executable) header metadata to a PDF report.
    This function adds a section titled "PE Metadata" to the provided PDF object,
    extracts PE header information from the specified file, and writes the metadata
    to the PDF. If the metadata contains section information, it lists each section's
    name, virtual address (VA), and size. Other metadata fields are displayed as key-value pairs.
    arguments:
        An object representing the PDF report, expected to have methods like
             section_title(), set_font(), cell(), and ln().
        The path to the file from which to extract PE header metadata.
    """
    pdf.section_title("PE Metadata")
    peinfo = detect_pe_headers(file_path)
    for key, value in peinfo.items():
        if key == "sections":
            pdf.set_font("Arial", "B", 10)
            pdf.cell(0, 7, "Sections:", ln=True)
            pdf.set_font("Arial", "", 10)
            for section in value:
                pdf.cell(8)
                pdf.cell(
                    0,
                    7,
                    f"Name: {section[0]}, VA: {section[1]}, Size: {section[2]}",
                    ln=True,
                )
            pdf.ln(1)
        else:
            pdf.cell(30, 7, f"{key.replace('_', ' ').title()}:", border=0)
            pdf.cell(0, 7, str(value), ln=True)


def write_suspicious_filenames(pdf, file_path, ascii_strings):
    """
    Analyzes the given file name and its extracted ASCII strings for suspicious file name patterns,
    and writes the findings to a PDF report.
    arguments:
        An object representing the PDF report, expected to have methods for adding section titles,
             itemized lists, and highlighted text.
        The path to the file being analyzed.
        A list of ASCII strings extracted from the file content.
    """
    pdf.section_title("Suspicious Filenames")
    detection_results = detect_suspicious_file_names(file_path, ascii_strings)

    if detection_results["found"]:
        # Report filename matches
        for suspicious_name in detection_results["filename_matches"]:
            pdf.item_list(
                [f"File name matches suspicious pattern: {suspicious_name}"],
                color=(220, 90, 90),
            )

        # Report embedded matches
        for suspicious_name in detection_results["embedded_matches"]:
            pdf.item_list(
                [f"{suspicious_name}"],
                color=(190, 100, 100),
            )
    else:
        pdf.highlight_text(
            "No suspicious file names detected in file name or content.")


def write_suspicious_keywords(pdf, ascii_strings):
    """
    Analyzes a list of ASCII strings for suspicious keywords and writes the results to a PDF report.
    arguments:
        - An object representing the PDF report, expected to have methods for adding section titles,
            item lists, and highlighted text.
        - The list of ASCII strings extracted from a file to be analyzed for suspicious keywords.
    """
    pdf.section_title("Suspicious Keywords")
    detection_results = detect_suspicious_keywords(ascii_strings)

    if detection_results["found"]:
        pdf.item_list(
            [f"{keyword}" for keyword in detection_results["keywords_detected"]],
            color=(210, 70, 70),
        )
    else:
        pdf.highlight_text("No suspicious keywords detected.")


def write_suspicious_domains(pdf, ascii_strings):
    """
    Scans a list of ASCII strings for suspicious domain patterns and writes the results
    to a PDF report. This function performs comprehensive domain detection including:
    - Direct regex pattern matching against known suspicious domains
    - URL extraction and analysis (http/https URLs)
    - Domain-only extraction from various contexts

    arguments:
        - An object representing the PDF report, expected to have methods `section_title`,
            `item_list`, and `highlight_text`.
        - A list of ASCII strings to be scanned for suspicious domains.
    """
    pdf.section_title("Suspicious Domains")
    detection_results = detect_suspicious_domains(ascii_strings)

    if detection_results["found"]:
        pdf.item_list(
            detection_results["domains_detected"], color=(170, 120, 70))
    else:
        pdf.highlight_text("No suspicious domains detected.")


def write_ip_addresses(pdf, ascii_strings):
    """
    Extracts and writes detected IP addresses from a list of ASCII strings to a PDF report section.
    arguments:
        An object representing the PDF report, expected to have methods `section_title`,
            `item_list`, and `highlight_text`.
        - A list of ASCII strings to search for IP addresses.
    """
    pdf.section_title("IP Addresses")
    detection_results = detect_ip_addresses(ascii_strings)

    if detection_results["found"]:
        pdf.item_list(detection_results["ip_addresses"], color=(25, 25, 120))
    else:
        pdf.highlight_text("No IP addresses detected.")


def write_powershell_commands(pdf, ascii_strings):
    """
    Writes a section to the PDF report detailing any detected PowerShell commands from a
    list of ASCII strings.
    arguments:
        - An object representing the PDF report, expected to have methods `section_title`,
          `item_list`, and `highlight_text`.
        A list of ASCII strings to search for PowerShell commands.
    """
    pdf.section_title("Powershell Commands")
    detection_results = detect_powershell_commands(ascii_strings)

    if detection_results["found"]:
        pdf.item_list(
            [f"{cmd}" for cmd in detection_results["powershell_commands"]],
            color=(100, 80, 200)
        )
    else:
        pdf.highlight_text("No suspicious PowerShell commands detected.")


def write_registry_paths(pdf, ascii_strings):
    """
    Writes a section to the PDF report listing suspicious registry paths found in the
    provided ASCII strings.
    arguments:
        - An object representing the PDF report, expected to have methods 'section_title',
            'item_list', and 'highlight_text'.
        - A list of ASCII strings to be searched for registry paths.
    """
    pdf.section_title("Registry Paths")
    detection_results = detect_registry_paths(ascii_strings)

    if detection_results["found"]:
        pdf.item_list(
            [f"{reg_path}" for reg_path in detection_results["registry_paths"]],
            color=(90, 140, 120),
        )
    else:
        pdf.highlight_text("No suspicious registry paths detected.")


def write_yara_patterns(pdf, ascii_strings):
    """
    Writes a section to the PDF report containing detected YARA-like rules from a list of ASCII strings.
    This function searches the provided list of ASCII strings for patterns matching the YARA rule regular expression.
    If any matches are found, they are listed in the PDF report under a "YARA-like Rules" section. If no matches are found,
    a highlighted message indicating the absence of YARA-like rules is added instead.
    arguments:
        An object representing the PDF report, expected to have methods `section_title`, `item_list`, and `highlight_text`.
        A list of ASCII strings to be scanned for YARA-like rule patterns.
    """
    pdf.section_title("YARA-like Rules")
    detection_results = detect_yara_patterns(ascii_strings)

    if detection_results["found"]:
        pdf.item_list(
            [f"{rule}" for rule in detection_results["yara_patterns"]],
            color=(100, 110, 190)
        )
    else:
        pdf.highlight_text("No YARA-like rules detected.")


def write_eicar_signature(pdf, binary_data):
    """
    Writes a section to the PDF report indicating whether the EICAR test signature is present in the given binary data.
    arguments:
        An object representing the PDF report, expected to have methods `section_title`, `item_list`, and `highlight_text`.
        The binary data to be scanned for the EICAR signature.
    """
    pdf.section_title("EICAR Signature")
    detection_results = detect_eicar_signature(binary_data)
    if detection_results["found"]:
        pdf.item_list(["EICAR test signature detected!"], color=(200, 30, 30))
    else:
        pdf.highlight_text("No EICAR test signature detected.")


def write_base64_strings(pdf, ascii_strings):
    """
    Writes a section to the PDF report containing detected Base64-encoded strings and their decoded previews.

    arguments:
        An object representing the PDF report, expected to have methods such as section_title, item_list, and highlight_text.
        A list of ASCII strings to be analyzed for Base64-encoded content.
    """
    pdf.section_title("Base64-Encoded Strings")
    base64_results = detect_base64_encoded_strings(ascii_strings)
    if base64_results:
        for base64_string, decoded_content in base64_results:
            # Convert binary data to safe ASCII representation
            preview = str(decoded_content[:32]).replace(
                "\u2022", "*").replace("•", "*")
            # Ensure all characters are ASCII
            safe_preview = preview.encode("ascii", "replace").decode("ascii")
            safe_base64 = base64_string[:30].encode(
                "ascii", "replace").decode("ascii")
            pdf.item_list(
                [
                    f"{safe_base64}... Decoded: [{safe_preview}]"
                ],
                color=(80, 100, 150),
            )
    else:
        pdf.highlight_text("No base64-encoded strings detected.")


def write_high_entropy_sections(pdf, binary_data):
    """
    Writes a section to the PDF report detailing high-entropy sections found in the provided binary data.
    This function analyzes the binary data for regions with high entropy, which may indicate packed or obfuscated code.
    It adds a titled section to the PDF, listing up to 10 detected high-entropy chunks with their offsets and entropy values.
    If no such sections are found, it highlights this fact in the report.
    arguments:
        An object representing the PDF report, expected to have methods for adding section titles, item lists, and highlighted text.
        The binary data to be analyzed for high-entropy sections.
    """
    pdf.section_title("High Entropy Sections")
    high_entropy_chunks = detect_high_entropy_sections(binary_data)
    if high_entropy_chunks:
        for offset, entropy_value in high_entropy_chunks[:10]:
            pdf.item_list(
                [f"Offset {hex(offset)} - Entropy: {entropy_value:.2f}"],
                color=(110, 70, 170),
            )
    else:
        pdf.highlight_text(
            "No high-entropy (packed/obfuscated) sections detected.")


def write_ascii_strings(pdf, ascii_strings, columns=3):
    """
    Writes a table of ASCII strings to a PDF document, displaying up to the first 100 strings in a specified number of columns.
    arguments:
        An instance of a PDF generation class with methods for setting fonts, colors, and adding cells/lines.
        The list of ASCII strings to display.
        The number of columns to arrange the strings into. Defaults to 4.
    notes:
        - Only the first 100 strings are displayed; if there are more, a note is added indicating how many were omitted.
    """
    pdf.section_title("All ASCII Strings (First 100")
    max_strings = 100
    display_strings = (
        ascii_strings[:max_strings]
        if len(ascii_strings) > max_strings
        else ascii_strings
    )

    pdf.set_font("Arial", "", 7)
    col_width = (pdf.w - 2 * pdf.l_margin) / columns
    pdf.set_fill_color(245, 245, 245)
    pdf.set_text_color(40, 40, 40)

    # Arrange into rows of 4 columns
    rows = [
        display_strings[i: i + columns]
        for i in range(0, len(display_strings), columns)
    ]
    for row in rows:
        for col in range(columns):
            val = row[col] if col < len(row) else ""
            pdf.cell(col_width, 4, val, border=0, align="L", fill=True)
        pdf.ln(4)

    pdf.set_text_color(0, 0, 0)
    pdf.set_font("Arial", "", 10)
    if len(ascii_strings) > max_strings:
        pdf.highlight_text(
            f"...{len(ascii_strings)-max_strings} more strings omitted for brevity."
        )


def generate_static_report_pdf(file_path, pdf_path="static_report.pdf"):
    """
    Generates a static malware analysis report in PDF format for the specified binary file.
    This function extracts various static features from the given binary file, such as ASCII strings,
    PE header information, suspicious filenames, malicious keywords, domains, IP addresses, PowerShell
    commands, registry paths, YARA patterns, EICAR signatures, base64 strings, high-entropy sections,
    and more. The extracted information is compiled into a structured PDF report for further analysis.
    arguments:
        The path to the binary file to be analyzed.
        The output path for the generated PDF report. Defaults to "static_report.pdf".
    """
    with open(file_path, "rb") as binary_file:
        binary_data = binary_file.read()

    ascii_strings = extract_ascii_strings_from_binary(binary_data)

    pdf = malware_pdf_report()
    pdf.add_page()

    # Header & Meta
    pdf.section_title(f"Malware Analysis Report: {Path("file_path").name}")
    pdf.highlight_text(
        f"Date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        "All results are for demonstration and academic research only.\n"
    )

    write_file_information(pdf, file_path)
    write_pe_header(pdf, file_path)
    write_suspicious_filenames(pdf, file_path, ascii_strings)
    write_suspicious_keywords(pdf, ascii_strings)
    write_suspicious_domains(pdf, ascii_strings)
    write_ip_addresses(pdf, ascii_strings)
    write_powershell_commands(pdf, ascii_strings)
    write_registry_paths(pdf, ascii_strings)
    write_yara_patterns(pdf, ascii_strings)
    write_eicar_signature(pdf, binary_data)
    write_base64_strings(pdf, ascii_strings)
    write_high_entropy_sections(pdf, binary_data)
    write_ascii_strings(pdf, ascii_strings)

    pdf.output(pdf_path)
    print(f"PDF Report written to {pdf_path}")


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(
            "Usage: python static_reporter_pdf.py <target_exe> [output_report.pdf]")
    else:
        output_pdf_path = sys.argv[2] if len(
            sys.argv) >= 3 else "static_report.pdf"
        generate_static_report_pdf(sys.argv[1], output_pdf_path)
