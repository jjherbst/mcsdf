#!/usr/bin/env python3
"""
Comprehensive Malware Analysis Report Generator

This script combines static analysis, VirusTotal analysis, and professional PDF reporting
into a single, comprehensive tool for malware research and analysis.

Features:
- Static malware analysis (PE headers, strings, entropy, suspicious patterns)
- VirusTotal integration using official vt-py library
- Professional PDF report generation with academic branding
- Comprehensive detection and analysis capabilities
- No duplication of analysis data

Usage:
    python malware_report.py <base_filename> [--api-key API_KEY] [--output report.pdf] [--skip-vt]
    
    Example: python malware_report.py malware --api-key YOUR_API_KEY
    This will analyze malware.pyc for static analysis and bin/malware.exe for VirusTotal

Requirements:
    pip install vt-py fpdf2 pefile

Author: Juan Herbst - Master Cyber Security and Digital Forensics
License: Educational/Research Use
"""

import argparse
import asyncio
import hashlib
import json
import os
import re
import sys
import time
import base64
import datetime
import pefile
from datetime import datetime as dt
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from math import log2

import vt
from fpdf import FPDF

# === Constants and Patterns ===

SUSPICIOUS_KEYWORDS = [
    "ransomware", "keylogger", "backdoor", "shellcode", "exploit", "virus",
    "trojan", "worm", "malware", "spyware", "adware", "phishing", "botnet",
    "exploit kit", "rootkit", "DDoS attack", "SQL injection", "XSS attack",
    "command injection", "buffer overflow"
]

SUSPICIOUS_DOMAINS = [
    r"fake\.hacker\.com", r"haxor\-c2\.example\.net", r"evil\.malicious\.com",
    r"malicious\.anonymous\.com", r"c2\..*\.com",
    r"evil\.[a-zA-Z0-9\-]+\.(com|net|org)",
    r"malicious\.[a-zA-Z0-9\-]+\.(com|net|org)",
    r"hacker\.[a-zA-Z0-9\-]+\.(com|net|org)",
    r"backdoor\.[a-zA-Z0-9\-]+\.(com|net|org)",
    r"trojan\.[a-zA-Z0-9\-]+\.(com|net|org)",
    r"botnet\.[a-zA-Z0-9\-]+\.(com|net|org)"
]

SUSPICIOUS_FILENAMES = [
    "wannacry.exe", "evil.dll", "payload.bin", "exploit.sys",
    "iloveyou", "stuxnet", "zues"
]

IP_REGEX = r"(?:[0-9]{1,3}\.){3}[0-9]{1,3}"
POWERSHELL_REGEX = r"powershell.+?(?:\-enc|\-encodedcommand)"
REGISTRY_PATH_REGEX = r"Software\\Microsoft\\Windows\\CurrentVersion\\Run"
YARA_RULE_REGEX = r"rule\s+\w+\s*\{[^}]+\}"
EICAR_SIGNATURE = b"X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"
HIGH_ENTROPY_THRESHOLD = 4.5

# === Professional PDF Report Class ===

class MalwareAnalysisReport(FPDF):
    """
    Professional PDF report generator for comprehensive malware analysis.
    Combines static analysis and VirusTotal results in a single, cohesive report.
    """

    def __init__(self):
        super().__init__()
        self.set_auto_page_break(auto=True, margin=16)
        self.set_margins(18, 20, 18)
        self.set_title("Comprehensive Malware Analysis Report")
        self.set_author("Juan Herbst - Master Cyber Security and Digital Forensics")
        self.set_creator("malware_report.py")

    def header(self):
        """Professional header with academic branding."""
        self.set_font("Helvetica", "B", 16)
        self.set_text_color(41, 49, 97)
        self.cell(0, 12, "Comprehensive Malware Analysis Report", new_x="LMARGIN", new_y="NEXT", align="C")
        self.ln(2)
        self.set_font("Helvetica", "", 10)
        self.set_text_color(90, 90, 90)
        self.cell(0, 7, "Static Analysis & VirusTotal Integration", new_x="LMARGIN", new_y="NEXT", align="C")
        self.cell(0, 7, "By Juan Herbst - Master Cyber Security and Digital Forensics", new_x="LMARGIN", new_y="NEXT", align="C")
        self.ln(3)
        self.set_draw_color(100, 120, 200)
        self.set_line_width(0.6)
        self.line(18, self.get_y(), 192, self.get_y())
        self.ln(4)

    def footer(self):
        """Professional footer with page numbers."""
        self.set_y(-15)
        self.set_font("Helvetica", "I", 8)
        self.set_text_color(128)
        current_year = dt.now().year
        self.cell(0, 8, f"Page {self.page_no()}   © {current_year} Academic Research - MCSDF", align="C")

    def section_title(self, title, subtitle=None):
        """Add a section title with optional subtitle."""
        self.ln(4)
        self.set_font("Helvetica", "B", 13)
        self.set_text_color(22, 37, 91)
        self.cell(0, 9, title, new_x="LMARGIN", new_y="NEXT")
        if subtitle:
            self.set_font("Helvetica", "", 10)
            self.set_text_color(95, 120, 160)
            self.cell(0, 7, subtitle, new_x="LMARGIN", new_y="NEXT")
        self.set_text_color(0, 0, 0)
        self.set_font("Helvetica", "", 10)
        self.ln(1)

    def value_table(self, info_dict):
        """Display key-value pairs in a formatted table."""
        self.set_font("Helvetica", "", 10)
        for key, value in info_dict.items():
            self.cell(40, 7, f"{key}:", border=0)
            self.set_text_color(30, 30, 30)
            # Use a smaller width to prevent overflow
            self.cell(0, 7, str(value)[:100], new_x="LMARGIN", new_y="NEXT")
            self.set_text_color(0, 0, 0)
        self.ln(1)

    def highlight_text(self, text, color=(240, 247, 255)):
        """Add highlighted text block."""
        self.set_fill_color(*color)
        self.set_font("Helvetica", "I", 10)
        self.multi_cell(0, 7, text, fill=True)
        self.set_font("Helvetica", "", 10)
        self.ln(1)

    def item_list(self, items, color=(0, 0, 0)):
        """Display bullet-point list with custom color."""
        self.set_text_color(*color)
        for item in items:
            self.cell(5)
            # Ensure the item string is not too long and doesn't cause layout issues
            safe_item = str(item)[:120] + "..." if len(str(item)) > 120 else str(item)
            self.cell(0, 6, f"- {safe_item}", new_x="LMARGIN", new_y="NEXT")
        self.set_text_color(0, 0, 0)
        self.ln(1)

    def detection_table(self, scan_results):
        """Add VirusTotal detection results table."""
        if not scan_results or not isinstance(scan_results, dict):
            self.highlight_text("No VirusTotal scan results available")
            return

        # Table headers
        self.set_font('Helvetica', 'B', 9)
        self.cell(50, 8, 'Antivirus Engine', 1, 0, 'C')
        self.cell(35, 8, 'Result', 1, 0, 'C')
        self.cell(30, 8, 'Version', 1, 0, 'C')
        self.cell(30, 8, 'Update', 1, 1, 'C')

        # Table content
        self.set_font('Helvetica', '', 8)
        count = 0
        for engine, details in scan_results.items():
            if count >= 20:  # Limit to first 20 results
                break
            
            if not details or not isinstance(details, dict):
                continue

            # Color coding based on detection
            if details.get('category') in ['malicious', 'suspicious']:
                self.set_fill_color(255, 200, 200)  # Red background
            elif details.get('category') == 'undetected':
                self.set_fill_color(200, 255, 200)  # Green background
            else:
                self.set_fill_color(255, 255, 255)  # White background

            engine_name = engine[:22] + "..." if len(engine) > 22 else engine
            result = details.get('result', 'N/A')
            result = result[:32] if result else 'Clean'
            version = details.get('version', 'N/A')
            version = version[:27] if version else 'N/A'
            update = details.get('update', 'N/A')
            update = update[:27] if update else 'N/A'

            self.cell(50, 6, engine_name, 1, 0, 'L', True)
            self.cell(35, 6, result, 1, 0, 'L', True)
            self.cell(30, 6, version, 1, 0, 'L', True)
            self.cell(30, 6, update, 1, 1, 'L', True)
            count += 1

        if count >= 20:
            self.ln(2)
            self.highlight_text(f"Showing first 20 results. Total engines: {len(scan_results)}")

    def ascii_strings_table(self, ascii_strings, columns=3, max_strings=100):
        """Display ASCII strings in a multi-column table format."""
        display_strings = (
            ascii_strings[:max_strings]
            if len(ascii_strings) > max_strings
            else ascii_strings
        )

        self.set_font("Helvetica", "", 7)
        col_width = (self.w - 2 * self.l_margin) / columns
        self.set_fill_color(245, 245, 245)
        self.set_text_color(40, 40, 40)

        # Arrange into rows of columns
        rows = [
            display_strings[i: i + columns]
            for i in range(0, len(display_strings), columns)
        ]
        for row in rows:
            for col in range(columns):
                val = row[col] if col < len(row) else ""
                # Truncate long strings for table display
                val = val[:25] + "..." if len(val) > 25 else val
                self.cell(col_width, 4, val, border=0, align="L", fill=True)
            self.ln(4)

        self.set_text_color(0, 0, 0)
        self.set_font("Helvetica", "", 10)
        if len(ascii_strings) > max_strings:
            self.highlight_text(
                f"...{len(ascii_strings)-max_strings} more strings omitted for brevity."
            )

# === VirusTotal Integration ===

class VirusTotalAnalyzer:
    """VirusTotal analyzer using the official vt-py library."""
    
    def __init__(self, api_key: str):
        self.api_key = api_key
        
    async def analyze_file(self, file_path: Path) -> Optional[Dict]:
        """Analyze a file with VirusTotal using the official library."""
        try:
            print(f"[*] Connecting to VirusTotal...")
            
            async with vt.Client(self.api_key) as client:
                file_hash = self._calculate_sha256(file_path)
                print(f"[*] File SHA-256: {file_hash}")
                
                # Try to get existing analysis first
                try:
                    print(f"[*] Checking for existing analysis...")
                    file_obj = await client.get_object_async(f"/files/{file_hash}")
                    print(f"[✓] Found existing analysis")
                    return self._convert_vt_object_to_dict(file_obj)
                
                except vt.APIError as e:
                    if e.code == "NotFoundError":
                        print(f"[*] File not found in database, uploading...")
                    else:
                        print(f"[✗] Error checking existing analysis: {e}")
                        return None
                
                # Upload file for analysis
                print(f"[*] Uploading file: {file_path.name}")
                
                with open(file_path, "rb") as f:
                    analysis = await client.scan_file_async(f, wait_for_completion=True)
                
                print(f"[✓] Analysis completed!")
                
                # Get the detailed file report
                file_obj = await client.get_object_async(f"/files/{file_hash}")
                return self._convert_vt_object_to_dict(file_obj)
                
        except vt.APIError as e:
            if "Invalid API key" in str(e):
                print(f"[✗] Invalid API key")
            elif "Quota exceeded" in str(e):
                print(f"[✗] API quota exceeded")
            else:
                print(f"[✗] VirusTotal API error: {e}")
            return None
        except Exception as e:
            print(f"[✗] Unexpected error: {e}")
            return None
    
    def _calculate_sha256(self, file_path: Path) -> str:
        """Calculate SHA-256 hash of a file."""
        sha256_hash = hashlib.sha256()
        with open(file_path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                sha256_hash.update(chunk)
        return sha256_hash.hexdigest()
    
    def _convert_vt_object_to_dict(self, vt_obj) -> Dict:
        """Convert VirusTotal object to dictionary format."""
        result = {
            "data": {
                "id": vt_obj.id,
                "type": vt_obj.type,
                "attributes": {}
            }
        }
        
        # Copy all attributes from the VT object
        for attr_name in dir(vt_obj):
            if not attr_name.startswith('_') and hasattr(vt_obj, attr_name):
                try:
                    attr_value = getattr(vt_obj, attr_name)
                    if not callable(attr_value) and attr_name not in ['id', 'type']:
                        result["data"]["attributes"][attr_name] = attr_value
                except:
                    continue
        
        return result

# === Static Analysis Functions ===

def extract_ascii_strings(binary_data, min_length=6):
    """Extract ASCII strings from binary data."""
    pattern = rb"[\x20-\x7E]{%d,}" % min_length
    ascii_strings = re.findall(pattern, binary_data)
    return [s.decode("ascii", errors="ignore") for s in ascii_strings]

def calculate_file_hashes(file_path: Path) -> Dict[str, str]:
    """Calculate multiple hash types for a file."""
    hashes = {'md5': hashlib.md5(), 'sha1': hashlib.sha1(), 'sha256': hashlib.sha256()}
    
    with open(file_path, 'rb') as file:
        while chunk := file.read(8192):
            for hasher in hashes.values():
                hasher.update(chunk)
    
    return {name: hasher.hexdigest() for name, hasher in hashes.items()}

def calculate_shannon_entropy(byte_sequence):
    """Calculate Shannon entropy for data."""
    if isinstance(byte_sequence, str):
        byte_sequence = byte_sequence.encode()
    if not byte_sequence:
        return 0.0
    
    frequency_table = [0] * 256
    for byte in byte_sequence:
        frequency_table[byte] += 1
    
    entropy = 0.0
    for byte_count in frequency_table:
        if byte_count:
            probability = byte_count / len(byte_sequence)
            entropy -= probability * log2(probability)
    return entropy

def detect_pe_headers(file_path):
    """Extract PE header information."""
    # For .pyc files, look for corresponding .exe in same directory
    if str(file_path).endswith('.pyc'):
        filename = Path(file_path).stem + '.exe'
        pe_file_path = Path(file_path).parent / filename
        print(f"[*] Looking for PE executable: {pe_file_path}")
        
        # Check if the converted path exists
        if not pe_file_path.exists():
            print(f"[⚠] PE executable not found: {pe_file_path}")
            return {
                "entry_point": "N/A (.pyc file - no corresponding .exe found)",
                "image_base": "N/A (.pyc file - no corresponding .exe found)",
                "sections": [("N/A", "N/A", "N/A")],
            }
    else:
        # Use the file as-is for PE analysis
        pe_file_path = file_path
    
    try:
        pe = pefile.PE(str(pe_file_path))
        return {
            "entry_point": hex(getattr(pe.OPTIONAL_HEADER, "AddressOfEntryPoint", 0)),
            "image_base": hex(getattr(pe.OPTIONAL_HEADER, "ImageBase", 0)),
            "sections": [
                (
                    section.Name.decode(errors="ignore").strip("\x00"),
                    hex(section.VirtualAddress),
                    hex(section.Misc_VirtualSize),
                )
                for section in pe.sections
            ],
        }
    except pefile.PEFormatError:
        return {
            "entry_point": "N/A (Not a valid PE file)",
            "image_base": "N/A (Not a valid PE file)",
            "sections": [("N/A", "N/A", "N/A")],
        }
    except FileNotFoundError:
        return {
            "entry_point": "N/A (File not found)",
            "image_base": "N/A (File not found)",
            "sections": [("N/A", "N/A", "N/A")],
        }
    except Exception as e:
        return {
            "entry_point": f"N/A (Error: {str(e)})",
            "image_base": f"N/A (Error: {str(e)})",
            "sections": [("N/A", "N/A", "N/A")],
        }

def analyze_static_indicators(file_path: Path, binary_data: bytes, ascii_strings: List[str]) -> Dict:
    """Perform comprehensive static analysis."""
    results = {}
    
    # File information
    file_stats = file_path.stat()
    results["file_info"] = {
        "File Name": file_path.name,
        "File Size": f"{file_stats.st_size:,} bytes",
        "Created": dt.fromtimestamp(file_stats.st_ctime).isoformat(),
        "Modified": dt.fromtimestamp(file_stats.st_mtime).isoformat(),
    }
    
    # Add hashes
    results["file_info"].update(calculate_file_hashes(file_path))
    
    # PE header analysis
    results["pe_info"] = detect_pe_headers(file_path)
    
    # Enhanced suspicious pattern detection
    results["suspicious_filenames"] = detect_suspicious_filenames(file_path, ascii_strings)
    
    results["suspicious_keywords"] = {
        "found": bool([kw for kw in SUSPICIOUS_KEYWORDS if any(kw.lower() in s.lower() for s in ascii_strings)]),
        "keywords_detected": [kw for kw in SUSPICIOUS_KEYWORDS if any(kw.lower() in s.lower() for s in ascii_strings)],
        "total_matches": len([kw for kw in SUSPICIOUS_KEYWORDS if any(kw.lower() in s.lower() for s in ascii_strings)])
    }
    
    results["suspicious_domains"] = detect_suspicious_domains_enhanced(ascii_strings)
    
    results["ip_addresses"] = {
        "found": bool(list(set(re.findall(IP_REGEX, " ".join(ascii_strings))))),
        "ip_addresses": list(set(re.findall(IP_REGEX, " ".join(ascii_strings)))),
        "total_matches": len(list(set(re.findall(IP_REGEX, " ".join(ascii_strings)))))
    }
    
    results["powershell_commands"] = {
        "found": bool([s for s in ascii_strings if re.search(POWERSHELL_REGEX, s, re.IGNORECASE)]),
        "powershell_commands": [s for s in ascii_strings if re.search(POWERSHELL_REGEX, s, re.IGNORECASE)],
        "total_matches": len([s for s in ascii_strings if re.search(POWERSHELL_REGEX, s, re.IGNORECASE)])
    }
    
    results["registry_paths"] = {
        "found": bool([s for s in ascii_strings if re.search(REGISTRY_PATH_REGEX, s)]),
        "registry_paths": [s for s in ascii_strings if re.search(REGISTRY_PATH_REGEX, s)],
        "total_matches": len([s for s in ascii_strings if re.search(REGISTRY_PATH_REGEX, s)])
    }
    
    # YARA pattern detection
    results["yara_patterns"] = detect_yara_patterns(ascii_strings)
    
    # Enhanced Base64 detection
    results["base64_strings"] = detect_base64_enhanced(ascii_strings)
    
    # High entropy detection
    results["high_entropy_sections"] = []
    for offset in range(0, len(binary_data) - 256, 256):
        chunk = binary_data[offset:offset + 256]
        entropy = calculate_shannon_entropy(chunk)
        if entropy >= HIGH_ENTROPY_THRESHOLD:
            results["high_entropy_sections"].append((offset, entropy))
    
    # EICAR signature
    results["eicar_detected"] = {
        "found": EICAR_SIGNATURE in binary_data,
        "signature_detected": EICAR_SIGNATURE in binary_data,
        "signature_info": "EICAR test signature detected!" if EICAR_SIGNATURE in binary_data else "No EICAR test signature detected"
    }
    
    return results

def detect_suspicious_domains_enhanced(ascii_strings):
    """Enhanced domain detection with URL extraction and comprehensive pattern matching."""
    all_strings = ascii_strings
    
    found_domains = set()  # Use set to avoid duplicates
    total_matches = 0

    # Join all strings for comprehensive search
    all_text = " ".join(all_strings)

    # Method 1: Direct pattern matching in individual strings
    for domain_pattern in SUSPICIOUS_DOMAINS:
        for string in all_strings:
            matches = re.findall(domain_pattern, string, re.IGNORECASE)
            for match in matches:
                found_domains.add(f"{string[:50]}")
                total_matches += 1

    # Method 2: Extract URLs (http/https) and check domains
    url_pattern = r'https?://(?:www\.)?([a-zA-Z0-9\-\.]+\.[a-zA-Z]{2,})'
    urls = re.findall(url_pattern, all_text, re.IGNORECASE)
    for url_domain in urls:
        # Check if extracted domain matches any suspicious pattern
        for domain_pattern in SUSPICIOUS_DOMAINS:
            if re.search(domain_pattern, url_domain, re.IGNORECASE):
                found_domains.add(f"{url_domain}")
                total_matches += 1
                break
        # Also check for suspicious keywords in domain names
        suspicious_keywords = ['evil', 'malicious', 'fake',
                               'hacker', 'c2', 'backdoor', 'trojan', 'botnet']
        if any(keyword in url_domain.lower() for keyword in suspicious_keywords):
            found_domains.add(f"{url_domain}")
            total_matches += 1

    # Method 3: General domain extraction (without protocol)
    domain_pattern = r'\b([a-zA-Z0-9\-]+\.(?:com|net|org|info|biz|co|io|me|tk|ml|ga|cf))\b'
    domains = re.findall(domain_pattern, all_text, re.IGNORECASE)
    for domain in domains:
        # Check against suspicious patterns
        for suspicious_pattern in SUSPICIOUS_DOMAINS:
            if re.search(suspicious_pattern, domain, re.IGNORECASE):
                found_domains.add(f"Domain: {domain}")
                total_matches += 1
                break
        # Check for suspicious keywords in domain
        suspicious_keywords = ['evil', 'malicious', 'fake',
                               'hacker', 'c2', 'backdoor', 'trojan', 'botnet']
        if any(keyword in domain.lower() for keyword in suspicious_keywords):
            found_domains.add(f"{domain}")
            total_matches += 1

    return {
        "found": bool(found_domains),
        "domains_detected": sorted(list(found_domains)),
        "total_matches": total_matches
    }

def detect_suspicious_filenames(file_path: Path, ascii_strings: List[str]):
    """Detect suspicious filenames in file name and embedded content."""
    filename_matches = []
    embedded_matches = []

    for suspicious_name in SUSPICIOUS_FILENAMES:
        # Check if suspicious name is in the actual filename
        if suspicious_name.lower() in file_path.name.lower():
            filename_matches.append(suspicious_name)

        # Check if suspicious name is embedded in the file content
        elif any(suspicious_name.lower() in string.lower() for string in ascii_strings):
            embedded_matches.append(suspicious_name)

    return {
        "found": bool(filename_matches or embedded_matches),
        "filename_matches": filename_matches,
        "embedded_matches": embedded_matches
    }

def detect_yara_patterns(ascii_strings: List[str]):
    """Detect YARA-like rule patterns in strings."""
    yara_patterns = [
        string for string in ascii_strings if re.search(YARA_RULE_REGEX, string)
    ]

    return {
        "found": bool(yara_patterns),
        "yara_patterns": yara_patterns,
        "total_matches": len(yara_patterns)
    }

def detect_base64_enhanced(ascii_strings: List[str], min_length=16):
    """Enhanced base64 detection with decoded content preview."""
    decoded_results = []
    for string_candidate in ascii_strings:
        if len(string_candidate) >= min_length and re.fullmatch(
            r"[A-Za-z0-9+/=]+", string_candidate
        ):
            try:
                decoded_bytes = base64.b64decode(string_candidate, validate=True)
                decoded_results.append((string_candidate, decoded_bytes[:32]))
            except Exception:
                continue
    
    return {
        "found": bool(decoded_results),
        "base64_strings": decoded_results,
        "total_matches": len(decoded_results)
    }

# === Report Generation Functions ===

async def generate_comprehensive_report(pyc_file_path: Path, exe_file_path: Path, output_path: Path, api_key: Optional[str] = None, skip_vt: bool = False, exe_exists: bool = True) -> bool:
    """Generate comprehensive malware analysis report."""
    try:
        print(f"=== Starting Comprehensive Malware Analysis ===")
        print(f"[*] Analyzing Python file: {pyc_file_path.name}")
        if exe_exists:
            print(f"[*] Executable available for VirusTotal: {exe_file_path.name}")
        
        # Read file data from .pyc file for static analysis
        with open(pyc_file_path, 'rb') as f:
            binary_data = f.read()
        
        # Extract strings from .pyc file
        ascii_strings = extract_ascii_strings(binary_data)
        print(f"[*] Extracted {len(ascii_strings)} ASCII strings from {pyc_file_path.name}")
        
        # Perform static analysis on .pyc file
        print(f"[*] Performing static analysis on {pyc_file_path.name}...")
        static_results = analyze_static_indicators(pyc_file_path, binary_data, ascii_strings)
        
        # VirusTotal analysis on .exe file (if available)
        vt_results = None
        if not skip_vt and api_key and exe_exists:
            print(f"[*] Performing VirusTotal analysis on {exe_file_path.name}...")
            vt_analyzer = VirusTotalAnalyzer(api_key)
            vt_results = await vt_analyzer.analyze_file(exe_file_path)
        elif skip_vt:
            print(f"[*] Skipping VirusTotal analysis as requested")
        elif not exe_exists:
            print(f"[*] Skipping VirusTotal analysis (no executable file available)")
        else:
            print(f"[*] Skipping VirusTotal analysis (no API key)")
        
        # Generate PDF report
        print(f"[*] Generating comprehensive PDF report...")
        pdf = MalwareAnalysisReport()
        pdf.add_page()
        
        # === EXECUTIVE SUMMARY ===
        pdf.section_title("Executive Summary")
        
        # Count threats
        threat_count = 0
        threat_details = []
        
        if static_results["suspicious_keywords"]["found"]:
            threat_count += static_results["suspicious_keywords"]["total_matches"]
            threat_details.append(f"- {static_results['suspicious_keywords']['total_matches']} suspicious keywords detected")
        
        if static_results["suspicious_filenames"]["found"]:
            count = len(static_results["suspicious_filenames"]["filename_matches"]) + len(static_results["suspicious_filenames"]["embedded_matches"])
            threat_count += count
            threat_details.append(f"- {count} suspicious filename patterns found")
        
        if static_results["suspicious_domains"]["found"]:
            threat_count += static_results["suspicious_domains"]["total_matches"]
            threat_details.append(f"- {static_results['suspicious_domains']['total_matches']} suspicious domains found")
        
        if static_results["eicar_detected"]["found"]:
            threat_count += 1
            threat_details.append("- EICAR test signature detected")
        
        if vt_results:
            vt_stats = vt_results.get("data", {}).get("attributes", {}).get("last_analysis_stats", {})
            malicious = vt_stats.get("malicious", 0)
            suspicious = vt_stats.get("suspicious", 0)
            if malicious > 0 or suspicious > 0:
                threat_count += malicious + suspicious
                threat_details.append(f"- {malicious} malicious + {suspicious} suspicious VirusTotal detections")
        
        # Summary text
        if threat_count == 0:
            pdf.highlight_text("ANALYSIS RESULT: No significant threats detected.", (200, 255, 200))
        elif threat_count < 5:
            pdf.highlight_text(f"ANALYSIS RESULT: Low threat level - {threat_count} indicators found.", (255, 255, 200))
        else:
            pdf.highlight_text(f"ANALYSIS RESULT: High threat level - {threat_count} indicators found.", (255, 200, 200))
        
        if threat_details:
            pdf.item_list(threat_details)
        
        # === FILE INFORMATION ===
        pdf.section_title("File Information")
        
        # Add note about which files were analyzed
        analysis_note = f"Static analysis performed on: {pyc_file_path.name}"
        if exe_exists and vt_results:
            analysis_note += f" | VirusTotal analysis performed on: {exe_file_path.name}"
        elif exe_exists:
            analysis_note += f" | Executable available but not analyzed: {exe_file_path.name}"
        else:
            analysis_note += " | No executable file available for VirusTotal analysis"
        
        pdf.highlight_text(analysis_note, (240, 240, 250))
        
        pdf.value_table(static_results["file_info"])
        
        # === PE HEADER INFORMATION ===
        pdf.section_title("PE Header Analysis")
        pe_info = static_results["pe_info"]
        pe_display = {k: v for k, v in pe_info.items() if k != "sections"}
        pdf.value_table(pe_display)
        
        if pe_info["sections"] and pe_info["sections"][0][0] != "N/A":
            pdf.set_font("Helvetica", "B", 10)
            pdf.cell(0, 7, "PE Sections:", new_x="LMARGIN", new_y="NEXT")
            pdf.set_font("Helvetica", "", 10)
            for section in pe_info["sections"]:
                pdf.cell(8)
                pdf.cell(0, 7, f"Name: {section[0]}, VA: {section[1]}, Size: {section[2]}", new_x="LMARGIN", new_y="NEXT")
            pdf.ln(1)
        
        # === VIRUSTOTAL RESULTS ===
        if vt_results:
            pdf.section_title("VirusTotal Analysis Results")
            
            vt_attrs = vt_results.get("data", {}).get("attributes", {})
            
            # Debug: Print available VirusTotal attributes
            print(f"[DEBUG] Available VirusTotal attributes: {list(vt_attrs.keys())}")
            
            # === FILE METADATA ===
            pdf.section_title("VirusTotal File Metadata", "File information from VirusTotal database")
            
            metadata_info = {}
            if vt_attrs.get("md5"):
                metadata_info["MD5"] = vt_attrs.get("md5", "N/A")
            if vt_attrs.get("sha1"):
                metadata_info["SHA1"] = vt_attrs.get("sha1", "N/A")
            if vt_attrs.get("sha256"):
                metadata_info["SHA256"] = vt_attrs.get("sha256", "N/A")
            if vt_attrs.get("size"):
                metadata_info["File Size"] = f"{vt_attrs.get('size', 0):,} bytes"
            if vt_attrs.get("type_description"):
                metadata_info["File Type"] = vt_attrs.get("type_description", "N/A")
            if vt_attrs.get("meaningful_name"):
                metadata_info["Meaningful Name"] = vt_attrs.get("meaningful_name", "N/A")
            if vt_attrs.get("magic"):
                metadata_info["Magic"] = vt_attrs.get("magic", "N/A")
            if vt_attrs.get("first_submission_date"):
                from datetime import datetime
                first_submission = vt_attrs.get("first_submission_date")
                if isinstance(first_submission, datetime):
                    first_seen = first_submission.isoformat()
                else:
                    first_seen = datetime.fromtimestamp(first_submission).isoformat()
                metadata_info["First Seen"] = first_seen
            if vt_attrs.get("last_submission_date"):
                last_submission = vt_attrs.get("last_submission_date")
                if isinstance(last_submission, datetime):
                    last_seen = last_submission.isoformat()
                else:
                    last_seen = datetime.fromtimestamp(last_submission).isoformat()
                metadata_info["Last Seen"] = last_seen
            if vt_attrs.get("times_submitted"):
                metadata_info["Times Submitted"] = str(vt_attrs.get("times_submitted", 0))
            if vt_attrs.get("reputation"):
                metadata_info["Reputation Score"] = str(vt_attrs.get("reputation", 0))
            
            if metadata_info:
                pdf.value_table(metadata_info)
            
            # === THREAT CLASSIFICATION ===
            pdf.section_title("Threat Classification", "Threat intelligence from VirusTotal")
            threat_info = {}
            if vt_attrs.get("popular_threat_classification"):
                threat_class = vt_attrs.get("popular_threat_classification", {})
                if threat_class.get("suggested_threat_label"):
                    threat_info["Threat Family"] = threat_class.get("suggested_threat_label", "N/A")
                if threat_class.get("popular_threat_category"):
                    threat_info["Threat Category"] = str(threat_class.get("popular_threat_category", "N/A"))
            
            if vt_attrs.get("type_tags"):
                threat_info["Type Tags"] = ", ".join(vt_attrs.get("type_tags", []))
            
            # Always show this section, even if empty
            if not threat_info:
                threat_info["Status"] = "No threat classification available"
            pdf.value_table(threat_info)
            
            # === THREAT NAMES ===
            pdf.section_title("Threat Names", "Threat names identified by various engines")
            if vt_attrs.get("threat_names"):
                threat_names = vt_attrs.get("threat_names", [])
                if threat_names:
                    pdf.item_list(threat_names[:20], color=(200, 50, 50))  # Limit to first 20
                    if len(threat_names) > 20:
                        pdf.highlight_text(f"...{len(threat_names)-20} more threat names omitted for brevity.")
                else:
                    pdf.highlight_text("No threat names available")
            else:
                pdf.highlight_text("No threat names available")
            
            # === DETECTION STATISTICS ===
            vt_stats = vt_attrs.get("last_analysis_stats", {})
            if vt_stats:
                pdf.section_title("Detection Statistics", "Summary of antivirus engine results")
                total_scans = sum(vt_stats.values())
                malicious = vt_stats.get("malicious", 0)
                suspicious = vt_stats.get("suspicious", 0)
                undetected = vt_stats.get("undetected", 0)
                
                stats_info = {
                    "Total Engines": str(total_scans),
                    "Malicious Detections": str(malicious),
                    "Suspicious Detections": str(suspicious),
                    "Clean Results": str(undetected),
                    "Detection Ratio": f"{malicious + suspicious}/{total_scans}",
                    "Last Analysis": datetime.fromtimestamp(vt_attrs.get("last_analysis_date", 0)).isoformat() if vt_attrs.get("last_analysis_date") and isinstance(vt_attrs.get("last_analysis_date"), (int, float)) else vt_attrs.get("last_analysis_date").isoformat() if isinstance(vt_attrs.get("last_analysis_date"), datetime) else "N/A"
                }
                pdf.value_table(stats_info)
            
            # === COMMUNITY INTELLIGENCE ===
            pdf.section_title("Community Intelligence", "Community votes and comments")
            community_info = {}
            if vt_attrs.get("votes"):
                votes = vt_attrs.get("votes", {})
                community_info["Harmless Votes"] = str(votes.get("harmless", 0))
                community_info["Malicious Votes"] = str(votes.get("malicious", 0))
            if vt_attrs.get("comment_count"):
                community_info["Comments"] = str(vt_attrs.get("comment_count", 0))
            
            # Always show this section
            if not community_info:
                community_info["Status"] = "No community data available"
            pdf.value_table(community_info)
            
            # === YARA RESULTS ===
            pdf.section_title("YARA Rule Matches", "Community YARA rules that matched this file")
            if vt_attrs.get("crowdsourced_yara_results"):
                yara_results = vt_attrs.get("crowdsourced_yara_results", [])
                if yara_results:
                    yara_matches = []
                    for yara_match in yara_results[:10]:  # Limit to first 10
                        rule_name = yara_match.get("rule_name", "Unknown")
                        source = yara_match.get("source", "Unknown")
                        yara_matches.append(f"{rule_name} (by {source})")
                    pdf.item_list(yara_matches, color=(100, 100, 200))
                    if len(yara_results) > 10:
                        pdf.highlight_text(f"...{len(yara_results)-10} more YARA matches omitted for brevity.")
                else:
                    pdf.highlight_text("No YARA rule matches found")
            else:
                pdf.highlight_text("No YARA rule matches found")
            
            # === SANDBOX ANALYSIS ===
            pdf.section_title("Sandbox Analysis", "Behavioral analysis results")
            if vt_attrs.get("sandbox_verdicts"):
                sandbox_verdicts = vt_attrs.get("sandbox_verdicts", {})
                if sandbox_verdicts:
                    sandbox_info = {}
                    for sandbox_name, verdict_data in sandbox_verdicts.items():
                        if isinstance(verdict_data, dict) and verdict_data.get("category"):
                            sandbox_info[sandbox_name] = verdict_data.get("category", "Unknown")
                        elif isinstance(verdict_data, str):
                            sandbox_info[sandbox_name] = verdict_data
                    if sandbox_info:
                        pdf.value_table(sandbox_info)
                    else:
                        pdf.highlight_text("No sandbox analysis results available")
                else:
                    pdf.highlight_text("No sandbox analysis results available")
            else:
                pdf.highlight_text("No sandbox analysis results available")
            
            # === BEHAVIORAL INDICATORS ===
            pdf.section_title("Behavioral Summary", "Behavioral analysis indicators")
            if vt_attrs.get("behaviour_summary"):
                behavior = vt_attrs.get("behaviour_summary", {})
                if behavior:
                    behavior_info = {}
                    if behavior.get("files_written"):
                        behavior_info["Files Written"] = str(len(behavior.get("files_written", [])))
                    if behavior.get("files_deleted"):
                        behavior_info["Files Deleted"] = str(len(behavior.get("files_deleted", [])))
                    if behavior.get("registry_keys_set"):
                        behavior_info["Registry Keys Set"] = str(len(behavior.get("registry_keys_set", [])))
                    if behavior.get("processes_created"):
                        behavior_info["Processes Created"] = str(len(behavior.get("processes_created", [])))
                    if behavior.get("network_connections"):
                        behavior_info["Network Connections"] = str(len(behavior.get("network_connections", [])))
                    
                    if behavior_info:
                        pdf.value_table(behavior_info)
                    else:
                        pdf.highlight_text("No behavioral indicators available")
                else:
                    pdf.highlight_text("No behavioral indicators available")
            else:
                pdf.highlight_text("No behavioral indicators available")
            
            # === NETWORK ACTIVITY ===
            pdf.section_title("Network Activity", "Network connections observed during analysis")
            network_info = []
            if vt_attrs.get("contacted_domains"):
                domains = vt_attrs.get("contacted_domains", [])
                if domains:
                    network_info.extend([f"Domain: {domain}" for domain in domains[:10]])
            
            if vt_attrs.get("contacted_ips"):
                ips = vt_attrs.get("contacted_ips", [])
                if ips:
                    network_info.extend([f"IP: {ip}" for ip in ips[:10]])
            
            if vt_attrs.get("contacted_urls"):
                urls = vt_attrs.get("contacted_urls", [])
                if urls:
                    network_info.extend([f"URL: {url}" for url in urls[:5]])
            
            if network_info:
                pdf.item_list(network_info, color=(50, 100, 150))
            else:
                pdf.highlight_text("No network activity recorded")
            
            # === PACKERS/PROTECTORS ===
            pdf.section_title("Packers/Protectors", "Detected packers and protectors")
            if vt_attrs.get("packers"):
                packers = vt_attrs.get("packers", {})
                if packers:
                    packer_list = []
                    for packer_name, packer_info in packers.items():
                        if isinstance(packer_info, str):
                            packer_list.append(f"{packer_name}: {packer_info}")
                        else:
                            packer_list.append(packer_name)
                    pdf.item_list(packer_list, color=(150, 100, 50))
                else:
                    pdf.highlight_text("No packers or protectors detected")
            else:
                pdf.highlight_text("No packers or protectors detected")
            
            # === PE INFORMATION ===
            pdf.section_title("VirusTotal PE Analysis", "PE header information from VirusTotal")
            if vt_attrs.get("pe_info"):
                pe_vt_info = vt_attrs.get("pe_info", {})
                if pe_vt_info:
                    pe_display_info = {}
                    if pe_vt_info.get("timestamp"):
                        pe_timestamp = pe_vt_info.get("timestamp")
                        if isinstance(pe_timestamp, datetime):
                            pe_display_info["PE Timestamp"] = pe_timestamp.isoformat()
                        else:
                            pe_display_info["PE Timestamp"] = datetime.fromtimestamp(pe_timestamp).isoformat()
                    if pe_vt_info.get("machine_type"):
                        pe_display_info["Machine Type"] = str(pe_vt_info.get("machine_type"))
                    if pe_vt_info.get("subsystem"):
                        pe_display_info["Subsystem"] = str(pe_vt_info.get("subsystem"))
                    if pe_vt_info.get("entry_point"):
                        pe_display_info["Entry Point"] = hex(pe_vt_info.get("entry_point"))
                    
                    if pe_display_info:
                        pdf.value_table(pe_display_info)
                    else:
                        pdf.highlight_text("No PE information available")
                else:
                    pdf.highlight_text("No PE information available")
            else:
                pdf.highlight_text("No PE information available")
            
            # === IMPORTS/EXPORTS ===
            pdf.section_title("Imported Functions", "Functions imported by the executable")
            if vt_attrs.get("imports"):
                imports = vt_attrs.get("imports", [])
                if imports:
                    import_list = []
                    for imp in imports[:20]:  # Limit to first 20
                        if isinstance(imp, dict):
                            lib_name = imp.get("library_name", "Unknown")
                            func_name = imp.get("function_name", "Unknown")
                            import_list.append(f"{lib_name}::{func_name}")
                        else:
                            import_list.append(str(imp))
                    pdf.item_list(import_list, color=(80, 80, 80))
                    if len(imports) > 20:
                        pdf.highlight_text(f"...{len(imports)-20} more imports omitted for brevity.")
                else:
                    pdf.highlight_text("No import information available")
            else:
                pdf.highlight_text("No import information available")
            
            # === ADDITIONAL VIRUSTOTAL SECTIONS ===
            
            # File type and classification
            pdf.section_title("File Classification", "File type and format information")
            file_class_info = {}
            if vt_attrs.get("type_description"):
                file_class_info["File Type"] = vt_attrs.get("type_description", "Unknown")
            if vt_attrs.get("type_extension"):
                file_class_info["Extension"] = vt_attrs.get("type_extension", "Unknown")
            if vt_attrs.get("magic"):
                file_class_info["Magic Bytes"] = vt_attrs.get("magic", "Unknown")
            if vt_attrs.get("ssdeep"):
                file_class_info["SSDeep Hash"] = vt_attrs.get("ssdeep", "N/A")[:50] + "..." if len(vt_attrs.get("ssdeep", "")) > 50 else vt_attrs.get("ssdeep", "N/A")
            
            if not file_class_info:
                file_class_info["Status"] = "No file classification available"
            pdf.value_table(file_class_info)
            
            # Signature information
            pdf.section_title("Digital Signatures", "Code signing and certificate information")
            if vt_attrs.get("signature_info"):
                sig_info = vt_attrs.get("signature_info", {})
                if sig_info and isinstance(sig_info, dict):
                    sig_display = {}
                    for key, value in sig_info.items():
                        sig_display[key.replace("_", " ").title()] = str(value)[:100]
                    pdf.value_table(sig_display)
                else:
                    pdf.highlight_text("No signature information available")
            else:
                pdf.highlight_text("No signature information available")
            
            # Detection results table (existing)
            scan_results = vt_attrs.get("last_analysis_results", {})
            if scan_results:
                pdf.section_title("Antivirus Detection Details", "Individual engine detection results")
                pdf.detection_table(scan_results)
        
        # === STATIC ANALYSIS RESULTS ===
        pdf.section_title("Static Analysis Results")
        
        # Suspicious filenames
        if static_results["suspicious_filenames"]["found"]:
            pdf.section_title("Suspicious Filenames", "Filenames that may indicate malicious behavior")
            if static_results["suspicious_filenames"]["filename_matches"]:
                pdf.item_list([f"File name matches: {name}" for name in static_results["suspicious_filenames"]["filename_matches"]], color=(220, 90, 90))
            if static_results["suspicious_filenames"]["embedded_matches"]:
                pdf.item_list([f"Embedded: {name}" for name in static_results["suspicious_filenames"]["embedded_matches"]], color=(190, 100, 100))
        
        # Suspicious keywords
        if static_results["suspicious_keywords"]["found"]:
            pdf.section_title("Suspicious Keywords Detected", "Keywords that may indicate malicious behavior")
            pdf.item_list(static_results["suspicious_keywords"]["keywords_detected"], color=(210, 70, 70))
        
        # Suspicious domains
        if static_results["suspicious_domains"]["found"]:
            pdf.section_title("Suspicious Domains", "Domains that may be used for malicious purposes")
            pdf.item_list(static_results["suspicious_domains"]["domains_detected"], color=(170, 120, 70))
        
        # IP addresses
        if static_results["ip_addresses"]["found"]:
            pdf.section_title("IP Addresses", "IP addresses found in the file")
            pdf.item_list(static_results["ip_addresses"]["ip_addresses"], color=(25, 25, 120))
        
        # PowerShell commands
        if static_results["powershell_commands"]["found"]:
            pdf.section_title("PowerShell Commands", "Potentially malicious PowerShell commands")
            pdf.item_list([cmd[:100] + "..." if len(cmd) > 100 else cmd for cmd in static_results["powershell_commands"]["powershell_commands"]], color=(100, 80, 200))
        
        # Registry paths
        if static_results["registry_paths"]["found"]:
            pdf.section_title("Registry Paths", "Registry paths that may be modified")
            pdf.item_list(static_results["registry_paths"]["registry_paths"], color=(90, 140, 120))
        
        # YARA patterns
        if static_results["yara_patterns"]["found"]:
            pdf.section_title("YARA-like Rules", "YARA rule patterns detected")
            pdf.item_list([rule[:100] + "..." if len(rule) > 100 else rule for rule in static_results["yara_patterns"]["yara_patterns"]], color=(100, 110, 190))
        
        # Base64 strings
        if static_results["base64_strings"]["found"]:
            pdf.section_title("Base64 Encoded Strings", "Potentially obfuscated content")
            for b64_string, decoded_content in static_results["base64_strings"]["base64_strings"][:10]:
                # Convert binary data to safe ASCII representation
                preview = str(decoded_content[:32]).replace("\u2022", "*").replace("•", "*")
                # Ensure all characters are ASCII
                safe_preview = preview.encode("ascii", "replace").decode("ascii")
                safe_base64 = b64_string[:30].encode("ascii", "replace").decode("ascii")
                pdf.item_list([f"{safe_base64}... -> {safe_preview}"], color=(80, 100, 150))
        
        # High entropy sections
        if static_results["high_entropy_sections"]:
            pdf.section_title("High Entropy Sections", "Potentially packed or encrypted content")
            for offset, entropy in static_results["high_entropy_sections"][:10]:
                pdf.item_list([f"Offset {hex(offset)} - Entropy: {entropy:.2f}"], color=(110, 70, 170))
        
        # EICAR detection
        if static_results["eicar_detected"]["found"]:
            pdf.section_title("EICAR Test Signature", "Test signature for antivirus validation")
            pdf.item_list([static_results["eicar_detected"]["signature_info"]], color=(200, 30, 30))
        
        # === STRING ANALYSIS ===
        if ascii_strings:
            pdf.section_title("String Analysis", f"First 100 of {len(ascii_strings)} extracted strings")
            
            # Use enhanced multi-column display
            pdf.ascii_strings_table(ascii_strings, columns=3, max_strings=100)
        
        # === CONCLUSION ===
        pdf.section_title("Analysis Conclusion")
        
        conclusion_text = f"Analysis completed on {dt.now().strftime('%Y-%m-%d %H:%M:%S')}. "
        
        if threat_count == 0:
            conclusion_text += "No significant malicious indicators were detected in this file. "
        elif threat_count < 5:
            conclusion_text += f"Low-level threat indicators detected ({threat_count} total). Further investigation may be warranted. "
        else:
            conclusion_text += f"High-level threat indicators detected ({threat_count} total). This file should be considered potentially malicious. "
        
        conclusion_text += "This analysis is for educational and research purposes only."
        
        pdf.highlight_text(conclusion_text)
        
        # Save PDF
        pdf.output(str(output_path))
        print(f"[✓] Comprehensive report saved to: {output_path}")
        return True
        
    except Exception as error:
        print(f"[✗] Error generating report: {error}")
        import traceback
        traceback.print_exc()
        return False

# === Main Functions ===

def parse_arguments() -> argparse.Namespace:
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="Comprehensive Malware Analysis Report Generator",
        epilog="This tool combines static analysis and VirusTotal integration for comprehensive malware analysis."
    )
    
    parser.add_argument(
        "file_base",
        type=str,
        help="Base filename of the malware (without extension, e.g. 'malware')"
    )
    
    parser.add_argument(
        "--api-key",
        type=str,
        help="VirusTotal API key (or set VT_API_KEY environment variable)"
    )
    
    parser.add_argument(
        "--output",
        type=Path,
        help="Output PDF report path (default: <base_filename>_comprehensive_report.pdf)"
    )
    
    parser.add_argument(
        "--skip-vt",
        action="store_true",
        help="Skip VirusTotal analysis (static analysis only)"
    )
    
    return parser.parse_args()

async def main_async() -> int:
    """Main async entry point."""
    print("=== Comprehensive Malware Analysis Report Generator ===")
    print("Static Analysis + VirusTotal Integration")
    print("Juan Herbst - Master Cyber Security and Digital Forensics\n")
    
    # Parse arguments
    args = parse_arguments()
    
    # Construct file paths from base filename
    base_name = args.file_base
    pyc_file_path = Path("bin") / f"{base_name}.pyc"
    exe_file_path = Path("bin") / f"{base_name}.exe"
    
    # Validate files exist
    if not pyc_file_path.exists():
        print(f"[✗] Python compiled file not found: {pyc_file_path}")
        return 1
    
    if not pyc_file_path.is_file():
        print(f"[✗] Not a file: {pyc_file_path}")
        return 1
    
    # Check if exe exists for VirusTotal analysis
    exe_exists = exe_file_path.exists() and exe_file_path.is_file()
    if not exe_exists:
        print(f"[⚠] Executable file not found: {exe_file_path}")
        print(f"[*] Will proceed with static analysis only on {pyc_file_path}")
    
    # Get API key
    api_key = args.api_key or os.getenv("VT_API_KEY")
    if not args.skip_vt and not api_key:
        print("[⚠] No VirusTotal API key provided. Continuing with static analysis only.")
        print("   Use --api-key or set VT_API_KEY environment variable for VirusTotal integration.")
        print("   Use --skip-vt to suppress this warning.\n")
    
    # Set output path
    if args.output:
        output_path = args.output
    else:
        output_path = Path(f"{base_name}_comprehensive_report.pdf")
    
    try:
        # Generate comprehensive report
        success = await generate_comprehensive_report(
            pyc_file_path, exe_file_path, output_path, api_key, args.skip_vt, exe_exists
        )
        
        if success:
            print(f"\n[✓] Analysis complete! Comprehensive report saved to: {output_path}")
            return 0
        else:
            print(f"\n[✗] Failed to generate report")
            return 1
            
    except KeyboardInterrupt:
        print("\n[*] Analysis interrupted by user")
        return 1
    except Exception as error:
        print(f"\n[✗] Unexpected error: {error}")
        return 1

def main() -> int:
    """Main entry point that runs the async function."""
    return asyncio.run(main_async())

if __name__ == "__main__":
    sys.exit(main())
